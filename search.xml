<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React路由设置createBrowserHistory之后页面刷新报错问题解决</title>
      <link href="/posts/2425023234/"/>
      <url>/posts/2425023234/</url>
      
        <content type="html"><![CDATA[<h2 id="React路由设置createBrowserHistory之后页面刷新报错问题解决"><a href="#React路由设置createBrowserHistory之后页面刷新报错问题解决" class="headerlink" title="React路由设置createBrowserHistory之后页面刷新报错问题解决"></a>React路由设置createBrowserHistory之后页面刷新报错问题解决</h2><p><strong><em>问题</em></strong></p><p>使用browserHistory时页面刷新时控制台会报错：<code>Uncaught SyntaxError: Unexpected token &lt;</code></p><p><strong><em>解决办法</em></strong></p><p>在index.html中修改资源引入路径，使用绝对路径进行引入</p><p>例如：</p><p><img alt="修改前" data-src="/posts/2425023234/before.png" class="lazyload"></p><p>使用绝对路径引入:</p><p><img alt="修改后" data-src="/posts/2425023234/after.png" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写防抖、节流</title>
      <link href="/posts/2442577863/"/>
      <url>/posts/2442577863/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>npm 依赖包版本号~和^的区别</title>
      <link href="/posts/2795930560/"/>
      <url>/posts/2795930560/</url>
      
        <content type="html"><![CDATA[<h2 id="npm-依赖包版本号-和-的区别"><a href="#npm-依赖包版本号-和-的区别" class="headerlink" title="npm 依赖包版本号~和^的区别"></a>npm 依赖包版本号~和^的区别</h2><ul><li><code>~</code>会匹配最近的小版本依赖包，比如<code>~1.2.3</code>会匹配所有1.2.x版本，但是不包括1.3.0</li><li><code>^</code>会匹配最新的大版本依赖包，比如<code>^1.2.3</code>会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0</li><li><code>*</code>会安装最新版本的依赖包</li></ul><p>那么该如何选择呢？当然你可以指定特定的版本号，直接写1.2.3，前面什么前缀都没有，这样固然没问题，但是如果依赖包发布新版本修复了一些小bug，那么需要手动修改package.json文件；<code>~</code>和<code>^</code>则可以解决这个问题。<br>但是需要注意<code>^</code>版本更新可能比较大，会造成项目代码错误，所以建议使用<code>~</code>来标记版本号，这样可以保证项目不会出现大的问题，也能保证包中的小bug可以得到修复。<br>版本号写<code>*</code>，这意味着安装最新版本的依赖包，但缺点同上，可能会造成版本不兼容，慎用！</p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrtipt标签的defer和async</title>
      <link href="/posts/1750268648/"/>
      <url>/posts/1750268648/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web Worker介绍</title>
      <link href="/posts/3671681857/"/>
      <url>/posts/3671681857/</url>
      
        <content type="html"><![CDATA[<h2 id="Web-Worker介绍"><a href="#Web-Worker介绍" class="headerlink" title="Web Worker介绍"></a>Web Worker介绍</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JavaScript采用的是单线程非阻塞模型，所有任务只能在一个线程上跑，一次只能做一件事。前面的任务没做完，后面的任务只能等着，随着多核CPU的出现，单线程带来的不便，无法充分发挥计算机的计算能力。</p><p><code>Web Worker</code>的出现，就是为JavaScript创造了多线程环境，允许主线程创建Worker线程，将一些任务分配给后者运行。在主线程运行的时候，Worker线程在后台运行，两者互不干扰，等到Worker线程计算完成，再把结果返回给主线程，这样的好处是，一些计算密集型或者高延迟的任务可以交给Worker线程来承担，主线程会很流畅，不会被阻塞或者拖慢。</p><p>但是Worker线程一旦新建成功，就会始终运行，不会被主线程的活动（比如用户点击按钮，提交表单）打断。这样有利于随时响应主线程的通信，但是这样也造成了Worker比较耗费资源，不应该过度使用,而且一旦使用完毕，应当立即关闭。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>Web Worker有以下几个使用注意点：</p><ul><li><p>同源限制</p><p>分配给Worker线程运行的脚本文件，必须与主线程的脚本文件同源</p></li><li><p>DOM限制</p><p>Worker线程所在的全局对象，与主线程不一样，无法读取主线程所在页面的DOM对象，也无法使用document, window, parent这些对象。但是Worker线程可以使用 navigator 和 location 对象</p></li><li><p>通信联系</p><p>Worker线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p></li><li><p>脚本限制</p><p>Worker线程不能使用alert和confirm方法，但可以使用XMLHttpRequest对象发出ajax请求</p></li><li><p>文件限制</p><p>Worker线程无法读取本地文件，即不能打开本机的文件系统（file://)，它所加载的脚本必须来自网络。</p></li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li><p>主线程</p><p>主线程采用new命令，调用Worker()构造函数，新建一个Worker线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var worker &#x3D; new Worker(&#39;work.js&#39;);</span></pre></td></tr></table></figure><p>Worker()构造函数接受一个脚本文件作为参数，该文件就是Worker线程所要执行的任务，如果读取脚本文件失败，Worker会默默的失败。</p><p>然后主线程调用Worker.postMessage()方法，向Worker发消息，方法的参数就是发送的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">worker.postMessage(&#39;hello world&#39;);</span></pre></td></tr></table></figure><p>接着主线程通过worker.onmessage指定监听函数，接受子线程发来的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">worker.onmessage &#x3D; function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;接收到子线程发来的消息：&#39; + event.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><p>Worker完成任务以后，主线程就可以把它关掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">worker.terminate();</span></pre></td></tr></table></figure></li><li><p>worker线程<br>worker线程内部需要一个监听函数，监听message事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">self.addEventListener(&#39;message&#39;, function(e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  self.postMessage(e.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>上面代码中，self代表子线程自身，即子线程的全局对象，等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">this.addEventListener(&#39;message&#39;, function(e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  self.postMessage(e.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 或</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">addEventListener(&#39;message&#39;, function(e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  self.postMessage(e.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>另外，</p><ol><li>worker使用完毕，为了节省系统资源，必须关闭。主线程使用<code>worker.terminate()</code>关闭worker线程, <code>self.close()</code>用于在Worker内部关闭自身。</li><li>Worker内部如果想加载其他脚本，有一个专门的方法<code>importScripts()</code>, 该方法可以同时加载多个脚本。: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">importScripts(&#39;script1.js&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;);</span></pre></td></tr></table></figure></li><li>主线程可以监听Worker是否发生错误，如果发生错误，Worker会触发主线程的error事件。worker内部也可以监听error事件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">worker.onerror(function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 或者</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">worker.addEventListener(&#39;error&#39;, function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><h3 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h3></li></ol><p>主线程于worker线程之间的通信内容，可以是文本，也可以是对象。需要注意的是，<code>这种通信是拷贝，是传值而不是传址</code>，worker对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行后的字符串传给worker，后者再将其还原。</p><p>但是这种拷贝的方式发送二进制数据会造成性能问题，比如主线程向worker发生一个500MB文件，默认情况下浏览器会生成一个原文件的拷贝，为了解决这个问题，JavaScript允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫<code>transferable objects</code>，这使得主线程可以快速把数据交给Worker，对应影像处理、声音处理、3D运算等就非常方便，不会产生性能负担。 </p><p>如果要直接转移数据的控制权，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; transferable objects 格式</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">worker.postMessage(arrayBuffer, [arrayBuffer]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 例子</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">var ab &#x3D; new ArrayBuffer(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">worker.postMessage(ab, [ab])</span></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MessageChannel消息通道</title>
      <link href="/posts/2399429143/"/>
      <url>/posts/2399429143/</url>
      
        <content type="html"><![CDATA[<h2 id="MessageChannel消息通道"><a href="#MessageChannel消息通道" class="headerlink" title="MessageChannel消息通道"></a>MessageChannel消息通道</h2><p>在浏览器环境中，常见的宏任务有 <code>setTimeout/setInterval</code>、<code>MessageChannel</code>、<code>postMessage</code> 和 <code>setImmediate</code>等。常见的微任务有 <code>Promise.then</code> 和 <code>MutationObserver</code>等。Vue中对于宏任务的实现，会优先监测是否支持原生<code>setImmediate</code>，这是一个高版本IE和Edge才支持的特性，不支持的话再去检测是否支持原生的<code>MessageChannel</code>，如果也不支持的话会降级为setTimeout 0。</p><h3 id="MessageChannel"><a href="#MessageChannel" class="headerlink" title="MessageChannel"></a>MessageChannel</h3><p><code>MessageChannel</code>允许我们创建一个新的消息通道，并通过它的两个<code>MessagePort</code>属性发送数据。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个管道</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">var channel &#x3D; new MessageChannel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取实例的两个端口</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">var port1 &#x3D; channel.port1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">var port2 &#x3D; channel.port2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 给每个端口绑定onmessage事件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">port1.onmessage &#x3D; function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    console.log(&quot;port1收到来自port2的数据：&quot; + event.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">port2.onmessage &#x3D; function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    console.log(&quot;port2收到来自port1的数据：&quot; + event.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个端口只要绑定了onmessage事件，就可以接受从另一个端口发出的消息</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">port1.postMessage(&quot;发送给port2&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">port2.postMessage(&quot;发送给port1&quot;);</span></pre></td></tr></table></figure><p>简单来说，<code>MessageChannel</code>创建了一个通信的管道，管道有两个端口，每个端口都是只读的。这两个端口都可以通过postMessage发送消息。当一个端口绑定了onmessage事件时，就可以接受从另一个端口发出的消息。</p><p>消息通道就像是一条左右贯通的管道，左右两个端口就是 port1 和 port2</p><p>这两个端口可以相互发送消息，port1 发送的消息可以在 port2 接收到，反之亦然</p><p><img alt="MessageChannel" data-src="/posts/2399429143/MessageChannel.png" class="lazyload"></p><h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><p><strong>深拷贝</strong></p><p>大部分需要深拷贝的场景，都可以使用以下代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">JSON.parse(JSON.stringify(object))</span></pre></td></tr></table></figure><p>但这种办法会忽略掉<code>undefined</code>、<code>null</code>、<code>symbol</code>和<code>循环引用的对象</code>，而通过<code>postMessage</code>方法传输的<code>message</code>是深拷贝的，可以拷贝undefined和循环引用的对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function deepClone(msg) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  var ms &#x3D; new MessageChannel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; onmessage是异步的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    ms.port1.onmessage &#x3D; function(e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      resolve(e.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    ms.port2.postMessage(msg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  var obj &#x3D; &#123;name: &#39;zs&#39;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  var obj1 &#x3D; await deepClone(obj);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  obj.age &#x3D; 18;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  console.log(obj); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  console.log(obj1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">test();</span></pre></td></tr></table></figure><p>但<code>MessageChannel</code>对于<code>Symbol</code>和<code>function</code>依然束手无策</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setImmediate函数</title>
      <link href="/posts/3084422494/"/>
      <url>/posts/3084422494/</url>
      
        <content type="html"><![CDATA[<h2 id="setImmediate函数"><a href="#setImmediate函数" class="headerlink" title="setImmediate函数"></a>setImmediate函数</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>setImmediate函数用来把一些需要长时间运行的操作放到一个回调函数中，并在浏览器完成其他操作后立即执行。使用此方法可以替代setTimeout(fn, 0)方法。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var immediateID &#x3D; setImmediate（func，[ param1，param2，...]）;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">var immediateID &#x3D; setImmediate（func）;</span></pre></td></tr></table></figure><ul><li>immediateID 是这次setImmediate方法设置的唯一ID,可以作为 window.clearImmediate 的参数.</li><li>func 是将要执行的回调函数，参数param1 param2 ..都会直接传给函数func</li><li>window.clearImmediate 方法可以用来取消通过setImmediate设置的将要执行的语句, 就像 window.clearTimeout 对应于 window.setTimeout一样.</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>此函数是非标准的，能存在很大的不兼容性，目前仅IE和Node.js 0.10+的最新版本实现。Firefox和谷歌不支持此函数！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的 MutationEvents 和 MutationObserver</title>
      <link href="/posts/3084422494/"/>
      <url>/posts/3084422494/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript中的-MutationEvents-和-MutationObserver"><a href="#JavaScript中的-MutationEvents-和-MutationObserver" class="headerlink" title="JavaScript中的 MutationEvents 和 MutationObserver"></a>JavaScript中的 MutationEvents 和 MutationObserver</h2><h3 id="MutationEvents"><a href="#MutationEvents" class="headerlink" title="MutationEvents"></a>MutationEvents</h3><p>MutationEvents是一系列dom树的变动的监听事件，总共有9种事件： </p><ul><li>DOMAttrModified</li><li>DOMAttributeNameChanged</li><li>DOMCharacterDataModified</li><li>DOMElementNameChanged</li><li>DOMNodeInserted</li><li>DOMNodeInsertedIntoDocument</li><li>DOMNodeRemoved</li><li>DOMNodeRemovedFromDocument</li><li>DOMSubtreeModified</li></ul><p><strong>用法</strong></p><p>以下是给document注册DOMNodeInserted事件的示例，当dom树结构发生变动时触发回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;DOMNodeInserted&quot;, function () &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; do something</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p><strong>注意</strong><br>MutationEvents 的所有事件都被设计成<code>不可取消</code>，意味着一旦注册之后不能再removeEventListener取消监听了。MutationEvents 事件机制是同步的，也就是说每次DOM修改就会触发，修改几次就触发几次，影响性能。</p><h3 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h3><p>MutationObserver, dom树的变动观察者，是用来<code>监听DOM树的更改</code>，它是作为旧的MutationEvents的替代品，它的出现就是为了解决MutationEvents的问题。</p><p>MutationObserver 是个构造器，接受一个函数作为参数，这个函数会在节点变化时回调，同时返回两个参数，mutations： 节点变化记录列表， observer： MutationObserver对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var observer &#x3D; new MutationObserver(function (mutations, observer) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>MutationObserver有三个方法：</p><ul><li>observe: 设置观察目标<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mutationObserver.observe(target[, options])</span></pre></td></tr></table></figure></li><li>disconnect: 阻止观察者观察任何改变</li><li>takeRecords: 清空记录队列并返回里面的内容</li></ul><p><strong>用法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 选择需要观察变动的节点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">const targetNode &#x3D; document.getElementById(&#39;some-id&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 观察器的配置（需要观察什么变动）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const config &#x3D; &#123; attributes: true, childList: true, subtree: true &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当观察到变动时执行的回调函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">const callback &#x3D; function(mutationsList, observer) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; Use traditional &#39;for loops&#39; for IE 11</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    for(let mutation of mutationsList) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        if (mutation.type &#x3D;&#x3D;&#x3D; &#39;childList&#39;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            console.log(&#39;A child node has been added or removed.&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        else if (mutation.type &#x3D;&#x3D;&#x3D; &#39;attributes&#39;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            console.log(&#39;The &#39; + mutation.attributeName + &#39; attribute was modified.&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个观察器实例并传入回调函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">const observer &#x3D; new MutationObserver(callback);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 以上述配置开始观察目标节点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">observer.observe(targetNode, config);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 之后，可停止观察</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">observer.disconnect();</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的事件循环</title>
      <link href="/posts/3084422494/"/>
      <url>/posts/3084422494/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript中的事件循环"><a href="#JavaScript中的事件循环" class="headerlink" title="JavaScript中的事件循环"></a>JavaScript中的事件循环</h2><h3 id="为什么会有事件循环"><a href="#为什么会有事件循环" class="headerlink" title="为什么会有事件循环"></a>为什么会有事件循环</h3><p>首先我们知道，<code>JavaScript是一门单线程的非阻塞的脚本语言</code></p><blockquote><ol><li><strong>单线程</strong>: JavaScripts是单线程的，指的是JavaScript引擎中解析和执行JavaScript的线程只有一个（主线程）， 每次只能做一件事情。单线程是必然的，因为如果JavaScript是多线程，那么当两个线程同时对一个dom进行操作，例如一个向其添加事件监听，而另一个删除了该dom，这个是矛盾的。</li><li><strong>非阻塞</strong>: 当我们的JavaScript代码运行一个异步任务的时候（像ajax等），主线程会挂起这个任务，然后异步任务返回结果的时候再根据特定的结果去执行相应的回调函数。</li></ol></blockquote><p>那么如何做到非阻塞呢？这就需要——<code>事件循环(Event Loop)</code></p><h3 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h3><p>下面这张图可以帮助您了解JavaScript的调用堆栈/事件循环/回调队列如何相互影响</p><p><img alt="Event Loop" data-src="/posts/3084422494/event_loop.png" class="lazyload"></p><p>当JavaScript代码执行的时候回将不同的变量存于内存中的不同位置：堆(heap)或者栈(stack)中来加以区分。其中，堆里存放的是一些对象，而栈中则存放的是一些基础类型变量以及对象的指针。</p><p><strong>执行栈</strong></p><p>当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方，这个地方就叫<code>执行栈</code>。</p><p>比如下面是一段同步执行的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function a() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    b();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;a&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">function b() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;b&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">a();</span></pre></td></tr></table></figure><p>下图演示的是代码的执行过程：<br><img alt="Sync " data-src="/posts/3084422494/sync.png" class="lazyload"></p><ol><li>执行函数a先入栈  </li><li>函数a中先执行函数b，b入栈</li><li>执行函数b，console.log(b)入栈</li><li>输出b，console.log(b)出栈</li><li>函数b执行完成，b出栈</li><li>console.log(‘a’)入栈，执行。输出a，出栈 </li><li>函数a执行完成，a出栈</li></ol><p>同步代码的执行过程比较简单，那异步的呢？</p><p>JavsScript引擎遇到一个异步事件后并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，JavaScript会将这个事件加入到与当前执行栈不同的另一个队列，称为<strong>事件队列</strong></p><p>被放入事件队列之后不会立即执行起回调，而是等待当前执行栈中的所有任务都执行完毕，主线程空闲状态，主线程会去查找事件队列中是否有任务，如果有，则取出排在第一位的事件，并把这个事件对应的回调放到执行栈中，然后执行其他的同步代码。</p><p>看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$.on(&#39;button&#39;, &#39;click&#39;, function onClick() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    setTimeout(function timer() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        console.log(&#39;You clicked the button!&#39;);    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;, 2000);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hi!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">setTimeout(function timeout() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    console.log(&quot;Click the button!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;, 5000);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">console.log(&quot;Welcome to loupe.&quot;);</span></pre></td></tr></table></figure><p>下图演示的是代码的执行过程：<br><img alt="Sync " data-src="/posts/3084422494/async.gif" class="lazyload"></p><p>来分析下执行过程：</p><ol><li>首先是，注册了点击事件，异步执行，这个时候会把它放到Web api中</li><li>console.log(“Hi!”)入栈，直接执行，输出Hi</li><li>执行setTimeout， 异步执行，先挂载起来</li><li>执行console.log(“Welcome to loupe.”)，输出Welcome to loupe.</li><li>5秒钟后，setTimeout执行回调，将回调放入事件队列中，一旦主线程空闲，则取出运行。</li><li>此时点击按钮，触发点击事件，将点击事件的回调放入到事件队列中，一旦主线程空闲，则取出运行</li><li>运行点击事件中的setTimeout</li><li>2秒后，setTimeout执行回调，将回调放入事件队列中，一旦主线程空闲，则取出运行。</li></ol><h2 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h2><h3 id="微任务——Micro-Task"><a href="#微任务——Micro-Task" class="headerlink" title="微任务——Micro-Task"></a>微任务——Micro-Task</h3><p>常见的有<code>process.nextTick</code>、<code>new Promise().then(callback)</code>、 <code>MutationObserver</code>,它们的优先级是<code>process.nextTick &gt; Promise = MutationObserver</code></p><h3 id="宏任务——Micro-Task"><a href="#宏任务——Micro-Task" class="headerlink" title="宏任务——Micro-Task"></a>宏任务——Micro-Task</h3><p>常见的有<code>setTimeout</code>、 <code>setInterval</code>、 <code>主代码块</code>、<code>I/O操作</code>、 <code>UI交互事件</code>、 <code>postMessage</code>等。优先级是<code>主代码块 &gt; setImmediate &gt; MessageChannel &gt; setTimeout / setInterval</code>，大部分浏览器会把DOM事件回调优先处理 因为要提升用户体验 给用户反馈，其次是network IO操作的回调，再然后是UIrender，之后的顺序就难以捉摸了，其实不同浏览器的表现也不太一样，这里不做过多讨论。</p><h3 id="事件循环的执行顺序"><a href="#事件循环的执行顺序" class="headerlink" title="事件循环的执行顺序"></a>事件循环的执行顺序</h3><p>异步任务的返回结果会被放到一个事件队列中，根据上面提到的异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。</p><p><code>Event Loop</code>的循环过程如下：</p><ol><li>执行一个宏任务(一般是主代码块),如果没有可选的宏任务，则直接处理微任务</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>执行过程中如果遇到宏任务，就将它添加到宏任务的任务队列中</li><li>执行一个宏任务完成之后，就需要检测微任务队列有没有需要执行的任务，有的话，全部执行，没有的话，进行下一步</li><li>检查渲染，然后<code>GUI</code>线程接管渲染，进行浏览器渲染</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（…循环上面的步骤）</li></ol><p>总结就是：<code>执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，等所有微任务执行完毕后，再回到宏任务中进行下一轮循环</code></p><p>看下面这个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">console.log(&#39;start&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;setTimeout&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;, 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(function() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;promise1&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;).then(function() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;promise2&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">console.log(&#39;end&#39;)</span></pre></td></tr></table></figure><p>分析一下流程：</p><ol><li>执行console.log(‘start’), 输出start</li><li>执行setTimeout，压入宏任务队列</li><li>执行promise.then，回调压入微任务队列</li><li>执行console.log(‘end’)，输出end</li><li>主流程属于宏任务，执行完成后接下来要执行微任务队列中的任务了，也就是执行promise.then,输出promise1</li><li>此时又promise的第二个回调函数，压入微任务队列。由于event loop会把当前的微任务队列一直执行完，所以继续执行promise的第二个回调函数，输出promise2</li><li>这时微任务队列已经为空，接下来主线程会进行一些UI渲染工作（非一定要做），然后开始下一轮event loop，执行宏任务队列的任务。</li><li>此时宏任务队列中仅剩下setTimeout的回调，输出setTimeout</li></ol><p>故最后的输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">start</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">end</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">promise then 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">promise then 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">setTimout</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Hooks之useCallback</title>
      <link href="/posts/6797/"/>
      <url>/posts/6797/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Hooks之useCallback"><a href="#React-Hooks之useCallback" class="headerlink" title="React Hooks之useCallback"></a>React Hooks之useCallback</h2><p>useCallback</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React.memo和useMemo的使用</title>
      <link href="/posts/56913/"/>
      <url>/posts/56913/</url>
      
        <content type="html"><![CDATA[<h2 id="React-memo和useMemo的使用"><a href="#React-memo和useMemo的使用" class="headerlink" title="React.memo和useMemo的使用"></a>React.memo和useMemo的使用</h2><p>在React的class Component时代，为了性能优化我们经常使用<code>pureComponent + shouldComponentUpdate</code>对组件进行深层次的控制。</p><p>到了Funciton Component时代，React也提供了<code>memo</code>和<code>useMemo</code>，以达到<code>pureComponent + shouldComponentUpdate</code>同样效果。</p><h3 id="先看个例子："><a href="#先看个例子：" class="headerlink" title="先看个例子："></a>先看个例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, memo, useMemo &#125; from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">import &#123; Input &#125; from &#39;antd&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">export default class TestMemo extends Component &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  state &#x3D; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    firstName: &#39;x&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    lastName: &#39;f&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  handleChange(key, value) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    this.setState(&#123; [key]: value &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;render&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    const &#123; firstName, lastName &#125; &#x3D; this.state;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &lt;Input label&#x3D;&#39;姓&#39; value&#x3D;&#123;firstName&#125; onChange&#x3D;&#123;e &#x3D;&gt; this.handleChange(&#39;firstName&#39;, e.target.value)&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &lt;Input label&#x3D;&#39;名&#39; value&#x3D;&#123;lastName&#125; onChange&#x3D;&#123;e &#x3D;&gt; this.handleChange(&#39;lastName&#39;, e.target.value)&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &lt;FristName name&#x3D;&#123;firstName&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &lt;LastName name&#x3D;&#123;lastName&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      &lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">function FristName(&#123;name&#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render firstName&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">function LastName(&#123;name&#125;) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render lastName&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>仔细分析上面的例子，不难发现，每次在父组件的两个Input输入框任意一个中输入值，两个子组件<code>FristName</code>和<code>LastName</code>都会跟着渲染，即使跟子组件并不相关的props更新了，也渲染了一遍。<code>理论上，父组件每次变化一个 state 都通过 props 传递给了子组件，那子组件就会重新执行渲染。（无论子组件有没有真正用到这个 props）</code>，这无疑是浪费的渲染。</p><h3 id="使用memo"><a href="#使用memo" class="headerlink" title="使用memo"></a>使用memo</h3><p>下面我们使用memo对<code>FirstName</code>组件进行改造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import &#123; memo &#125; from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">const propsAreEqual &#x3D; function(prevProps, nextProps) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return prevProps.name &#x3D;&#x3D;&#x3D; nextProps;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const FristName &#x3D; memo((&#123;name&#125;) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render firstName&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;, propsAreEqual);</span></pre></td></tr></table></figure><p>使用了memo改造之后，我们会发现，当改变firstName后，<code>FirstName</code>组件会跟着渲染，而当改变lastName后，在控制台里可以看到<code>render firstName</code>并没有打印，说明<code>FirstName</code>组件并没有渲染，达到了性能优化的目的。</p><h3 id="使用useMemo"><a href="#使用useMemo" class="headerlink" title="使用useMemo"></a>使用useMemo</h3><p>看上面说那个memo的例子，我们发现React.memo是需要包裹整个组件的，并且需要手动写一个方法比较那些具体的props不相同才进行re-render。</p><p>而在某些场景下，我们只是希望component的某些部分不要进行re-render，而不是整个component编剧要re-render，也就是需要局部pure的功能。</p><p><code>useMemo</code>是React自带的hooks API，基本用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import &#123; useMemo &#125; from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">const memoizedValue &#x3D; useMemo(memoizedFunction(), [memoizedParams]);</span></pre></td></tr></table></figure><p>useMemo()返回的是一个memoized值，只有当依赖项memoizedParams发生改变，才会重新调用memoizedFunction函数计算生成新的memoizedValue。memoizedParams不变时不会触发memoizedFunction函数。</p><p>需要注意的是：<code>useMemo是在render期间执行的，所以不能进行一些副作用操作，比如网络请求等。</code></p><p>如果没有提供依赖项即memoizedParams，则每次都会调用memoizedFunction函数计算memoizedValue。</p><p>回到我们的例子，我们希望只有当lastName发生改变时，才会去重新渲染LastName组件，即用useMemo包裹return部分渲染的逻辑，下面是使用useMemo改造后的LastName组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function FristName(&#123;name&#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render firstName out useMemo&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return useMemo(() &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;render firstName in useMemo&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;, [name]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>再次运行时，我们会发现，<code>render firstName out useMemo</code>一直会打印，当我们没有改变firstName时，在useMemo函数中的这句<code>render firstName in useMemo</code>并不会打印，只有改变了firstName的值时，才会打印。这就是useMemo<code>局部pure</code>的体现了。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack之tree shaking</title>
      <link href="/posts/42071/"/>
      <url>/posts/42071/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack之tree-shaking"><a href="#webpack之tree-shaking" class="headerlink" title="webpack之tree shaking"></a>webpack之tree shaking</h2><p>webpack从2.0开始引入tree shaking概念。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>先了解下webpack中几个相关概念：</p><ul><li><p>AST<br>AST对JS代码进行语法分析后得出的语法树（Abstract Syntax Tree）。AST语法树可以把一段JS代码的每一个语句转化成语法树中的一个节点。</p></li><li><p>DCE<br>Dead Code Elimination,在保持代码运行结果不变的前提下，去除无用的代码。这样的好处是：</p><ul><li>优化代码</li><li>减小程序体积</li><li>减少程序执行时间</li></ul><p>其中Dead Code指的是：</p><ul><li>程序中不会执行的代码（如不可能进入的分支，return之后的代码等）</li><li>写入变量之后不再读取的代码</li></ul></li></ul><p>tree shaking是 DCE 的一种方式，它可以在打包时忽略没有用到代码。</p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>首先需要知道webpack的运行机制：</p><ol><li><p>先使用babel-loader处理js文件</p><p> babel的配置文件中有一个preset配置项：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  preset: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    [&#39;env&#39;, &#123; &#39;module&#39;: false &#125;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p> 其中presets里的env有个module的配置项，设置为false，这是指示babel如何去处理impory和export等关键字，默认以require形式，设置为false则babel就不会把import，export转成require形式了，这也为webpack的tree shaking创造了条件。</p></li><li><p>然后webpack进行tree-shaking识别和记录，打包处理</p><p> <code>webpack在认定某块代码无用后，会再处理过程中写下一段注释。uplifyjs会根据这点注释去进行删除代码。</code></p><p> webpack负责对代码进行标记，把import&amp;export分为3类：</p><ul><li>所有import标记为 /* harmony import */ </li><li>被使用过的export标记为 /* harmony export([type]) */, 其中type和webpack有关，可能是binding，immutable等</li><li>没被使用过的import标记为 /* unused harmony export [FunctionName] */, 其中FunctionName即export的方法名称</li></ul></li><li><p>最后由uglifyjs根据webpack标识删除多余代码，进行代码压缩</p></li></ol><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>img标签的alt和title</title>
      <link href="/posts/8189/"/>
      <url>/posts/8189/</url>
      
        <content type="html"><![CDATA[<h2 id="img标签的alt和title属性"><a href="#img标签的alt和title属性" class="headerlink" title="img标签的alt和title属性"></a>img标签的alt和title属性</h2><p>在html的img标签中，有alt和title两个重要的属性。</p><h3 id="alt属性："><a href="#alt属性：" class="headerlink" title="alt属性："></a>alt属性：</h3><ul><li><p>如果图像没有下载或者加载失败，会用文字来代替图像显示。</p><p>  这一作用是为了给加载不出网页图片的用户提供图片信息，方便用户浏览网页，也方便维护网页。</p></li><li><p>搜索引擎可以通过这个属性的文字来抓取图片</p></li></ul><h3 id="title属性："><a href="#title属性：" class="headerlink" title="title属性："></a>title属性：</h3><ul><li>当网页上的图片被加载完成后，鼠标移动到上面去，会显示这个图片指定的属性文字，以对图片信息进行补充性说明。</li></ul>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object.freeze函数</title>
      <link href="/posts/3106097719/"/>
      <url>/posts/3106097719/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-freeze函数"><a href="#Object-freeze函数" class="headerlink" title="Object.freeze函数"></a>Object.freeze函数</h2><p>Object.freeze(),冻结函数，该方法用于冻结一个对象。<code>一个被冻结的对象将不能修改属性，删除已有属性或添加新的属性</code>。此外，<code>冻结一个对象之后，该对象的原型也不能被修改</code>。该方法的返回值为传入的对象。</p><p>看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; age: 18 &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Object.freeze(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">a.age &#x3D; 20;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">a.name &#x3D; &#39;zs&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">delete a.age; &#x2F;&#x2F; false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr></table></figure><p>同时冻结的对象的原型也不能被修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; age: 18 &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Object.freeze(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">var b &#x3D; a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">b.age &#x3D; 20;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">console.log(b); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr></table></figure><p>但是，Object.freeze()只是<code>浅冻结</code>，被冻结的对象并不总是不可变的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; name: &#123; firstName: &#39;zhang&#39; &#125; &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Object.freeze(a);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">a.name.firstName &#x3D; &#39;wang&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123; name: &#123; firstName: &quot;wang&quot; &#125; &#125;</span></pre></td></tr></table></figure><p>最后，需要注意的是，<code>只要freeze之后，就不能解除了</code>，所以使用这个API需要谨慎</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github Page 搭建个人博客（二）发布文章和url处理</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<p>前面我们已经搭建好了我们的博客网站，现在我们来发布新的文章吧！</p><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>新建文章，输入以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo new &#39;文章标题&#39;</span></pre></td></tr></table></figure><p>执行完成后，可以在根目录下/source</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github Page 搭建个人博客（一）安装</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建个人博客的方式有很多种，大多数都需要从各种网上代理商上买域名和服务器部署自己的博客系统。本文介绍的是使用 <code>Hexo</code> + <code>Github Page</code>来搭建，这是一种搭建速度最快，完全免费开源，不需要购买任何服务器资源即可运行的方式，而且有 many many 种博客主题供你选择。下面先简单介绍下<code>Hexo</code> 和 <code>Github Page</code>：</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Hexo</code> 是基于Node.js驱动的一款静态博客框架，除了官方提供的很多种主题，github上也有很多开发者分享的开源的主题，都可供使用者自由选择，而且切换主题也相当简单方便。<code>Github Page</code> 是 Github 提供的 一种静态网页托管服务，可以用来托管博客等静态网页资源，关键是免费的！结合使用<code>Hexo</code> + <code>Github Page</code> 可以帮助我们快速搭建个人博客。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>， <code>Hexo</code> 是基于Node.js的，所以需要准备Node环境。</li><li>创建<a href="https://github.com/" target="_blank" rel="noopener">github</a> 账号</li><li>安装<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>，将本地项目打包后生成的静态资源文件上传到github上进行托管。</li></ol><h2 id="Github上创建个人仓库"><a href="#Github上创建个人仓库" class="headerlink" title="Github上创建个人仓库"></a>Github上创建个人仓库</h2><p>首先创建个人仓库，用来存放博客所需要的文件资源：</p><p><img alt="github仓库名" data-src="/posts/undefined/hexo_1.jpg" class="lazyload"></p><p>这时候我们的博客站点<code>http://用户名.github.io</code>就建好了！当然由于是个空项目，访问是空白的。下面我们将使用hexo来创建一个项目来部署我们的站点。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ol><li>我们需要先安装<code>hexo-cli</code>脚手架，脚手架可以帮助我们创建一个完整可用的项目。在本地打开一个cmd窗口运行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span></pre></td></tr></table></figure></li><li>然后使用hexo新建一个项目：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo init 新建项目文件名</span></pre></td></tr></table></figure></li><li>安装npm包依赖:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install</span></pre></td></tr></table></figure>这时候我们打开刚刚新建的项目文件夹，看下目录结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">项目根目录</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">├── node_modules</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">├── scaffolds # 模版文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">|   ├── _drafts # 草稿文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">|   └── _posts # 文章Markdowm文件 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">└── themes  # 主题文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">├── package.json</span></pre></td></tr></table></figure>这时我们运行<code>hexo s</code>命令启动工程，其中 s 是 server 的缩写：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo s</span></pre></td></tr></table></figure>启动成功后，在浏览器中输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 回车就可以预览效果了！<br><img alt="预览效果" data-src="/posts/undefined/hexo_2.jpg" class="lazyload"></li></ol><p>可能到此处你会觉得奇怪，我们什么都没做，怎么就生成这么好看的一套页面出来了！那这就要归功于<code>hexo-theme</code>了。每一种<code>hexo-theme</code>都内置了大量的样式文件，我们只需简单的配置就能打造出非常酷炫好看的博客网站！hexo中提供了非常多种theme，除此之外，github上也有大量开源的theme供我们自主选择，免费使用！</p><h2 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h2><p>本地hexo博客系统开发完毕后，我们还需要部署到我们前面在github上创建的个人仓库里才能通过站点访问到。 </p><p>在部署之前，第一步，先安装一个插件<code>hexo-deployer-git</code>，用于本地hexo项目连接到远程git仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span></pre></td></tr></table></figure><p>第二步，打开项目根目录下的_config.yml配置文件配置远程github仓库的参数。直接拉到_config.yml文件末尾，找到deploy选项，按如下配置：<br><img alt="github配置" data-src="/posts/undefined/hexo_3.jpg" class="lazyload"></p><p>最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo g -d</span></pre></td></tr></table></figure><p>稍等一会，在浏览器访问网址： <code>https://用户名.github.io</code> 就会看到你的博客啦！！</p><h2 id="搞定"><a href="#搞定" class="headerlink" title="搞定"></a>搞定</h2><p>至此，我们的个人博客网站就创建好了！后续还会对博客网站加入改进，努力打造出一个炫酷精致的博客网站！</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to Panda-Wind&#39;s Blog</title>
      <link href="/posts/20593/"/>
      <url>/posts/20593/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://panda-wind.github.io/">Panda-Wind</a>! I will share some interesting things with you here.</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
