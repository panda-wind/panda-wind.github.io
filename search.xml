<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript中的事件循环</title>
      <link href="/posts/3084422494/"/>
      <url>/posts/3084422494/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript中的事件循环"><a href="#JavaScript中的事件循环" class="headerlink" title="JavaScript中的事件循环"></a>JavaScript中的事件循环</h2><h3 id="为什么会有事件循环"><a href="#为什么会有事件循环" class="headerlink" title="为什么会有事件循环"></a>为什么会有事件循环</h3><p>首先我们知道，<code>JavaScript是一门单线程的非阻塞的脚本语言</code></p><blockquote><ol><li><strong>单线程</strong>: JavaScripts是单线程的，指的是JavaScript引擎中解析和执行JavaScript的线程只有一个（主线程）， 每次只能做一件事情。单线程是必然的，因为如果JavaScript是多线程，那么当两个线程同时对一个dom进行操作，例如一个向其添加事件监听，而另一个删除了该dom，这个是矛盾的。</li><li><strong>非阻塞</strong>: 当我们的JavaScript代码运行一个异步任务的时候（像ajax等），主线程会挂起这个任务，然后异步任务返回结果的时候再根据特定的结果去执行相应的回调函数。</li></ol></blockquote><p>那么如何做到非阻塞呢？这就需要——<code>事件循环(Event Loop)</code></p><h3 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h3><p>下面这张图可以帮助您了解JavaScript的调用堆栈/事件循环/回调队列如何相互影响</p><p><img alt="Event Loop" data-src="/posts/3084422494/event_loop.png" class="lazyload"></p><p>当JavaScript代码执行的时候回将不同的变量存于内存中的不同位置：堆(heap)或者栈(stack)中来加以区分。其中，堆里存放的是一些对象，而栈中则存放的是一些基础类型变量以及对象的指针。</p><p><strong>执行栈</strong></p><p>当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方，这个地方就叫<code>执行栈</code>。</p><p>比如下面是一段同步执行的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function a() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    b();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;a&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">function b() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;b&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">a();</span></pre></td></tr></table></figure><p>下图演示的是代码的执行过程：<br><img alt="Sync " data-src="/posts/3084422494/sync.png" class="lazyload"></p><ol><li>执行函数a先入栈  </li><li>函数a中先执行函数b，b入栈</li><li>执行函数b，console.log(b)入栈</li><li>输出b，console.log(b)出栈</li><li>函数b执行完成，b出栈</li><li>console.log(‘a’)入栈，执行。输出a，出栈 </li><li>函数a执行完成，a出栈</li></ol><p>同步代码的执行过程比较简单，那异步的呢？</p><p>JavsScript引擎遇到一个异步事件后并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，JavaScript会将这个事件加入到与当前执行栈不同的另一个队列，称为<strong>事件队列</strong></p><p>被放入事件队列之后不会立即执行起回调，而是等待当前执行栈中的所有任务都执行完毕，主线程空闲状态，主线程会去查找事件队列中是否有任务，如果有，则取出排在第一位的事件，并把这个事件对应的回调放到执行栈中，然后执行其他的同步代码。</p><p>看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$.on(&#39;button&#39;, &#39;click&#39;, function onClick() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    setTimeout(function timer() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        console.log(&#39;You clicked the button!&#39;);    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;, 2000);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hi!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">setTimeout(function timeout() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    console.log(&quot;Click the button!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;, 5000);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">console.log(&quot;Welcome to loupe.&quot;);</span></pre></td></tr></table></figure><p>下图演示的是代码的执行过程：<br><img alt="Sync " data-src="/posts/3084422494/async.gif" class="lazyload"></p><p>来分析下执行过程：</p><ol><li>首先是，注册了点击事件，异步执行，这个时候会把它放到Web api中</li><li>console.log(“Hi!”)入栈，直接执行，输出Hi</li><li>执行setTimeout， 异步执行，先挂载起来</li><li>执行console.log(“Welcome to loupe.”)，输出Welcome to loupe.</li><li>5秒钟后，setTimeout执行回调，将回调放入事件队列中，一旦主线程空闲，则取出运行。</li><li>此时点击按钮，触发点击事件，将点击事件的回调放入到事件队列中，一旦主线程空闲，则取出运行</li><li>运行点击事件中的setTimeout</li><li>2秒后，setTimeout执行回调，将回调放入事件队列中，一旦主线程空闲，则取出运行。</li></ol><h2 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h2><p><strong>微任务——Micro-Task</strong><br>常见的有<code>process.nextTick</code>、<code>new Promise().then(callback)</code>、 <code>MutationObserver</code>,它们的优先级是<code>process.nextTick &gt; Promise = MutationObserver</code></p><p><strong>宏任务——Micro-Task</strong><br>常见的有<code>setTimeout</code>、 <code>setInterval</code>、 <code>主代码块</code>、<code>I/O操作</code>、 <code>UI交互事件</code>、 <code>postMessage</code>等。优先级是<code>主代码块 &gt; setImmediate &gt; MessageChannel &gt; setTimeout / setInterval</code>，大部分浏览器会把DOM事件回调优先处理 因为要提升用户体验 给用户反馈，其次是network IO操作的回调，再然后是UIrender，之后的顺序就难以捉摸了，其实不同浏览器的表现也不太一样，这里不做过多讨论。</p><p><strong>事件循环的执行顺序</strong> </p><p>异步任务的返回结果会被放到一个事件队列中，根据上面提到的异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。</p><p><code>Event Loop</code>的循环过程如下：</p><ol><li>执行一个宏任务(一般是主代码块),如果没有可选的宏任务，则直接处理微任务</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>执行过程中如果遇到宏任务，就将它添加到宏任务的任务队列中</li><li>执行一个宏任务完成之后，就需要检测微任务队列有没有需要执行的任务，有的话，全部执行，没有的话，进行下一步</li><li>检查渲染，然后<code>GUI</code>线程接管渲染，进行浏览器渲染</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（…循环上面的步骤）</li></ol><p>总结就是：<code>执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，等所有微任务执行完毕后，再回到宏任务中进行下一轮循环</code></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Hooks之useCallback</title>
      <link href="/posts/6797/"/>
      <url>/posts/6797/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Hooks之useCallback"><a href="#React-Hooks之useCallback" class="headerlink" title="React Hooks之useCallback"></a>React Hooks之useCallback</h2><p>useCallback</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React.memo和useMemo的使用</title>
      <link href="/posts/56913/"/>
      <url>/posts/56913/</url>
      
        <content type="html"><![CDATA[<h2 id="React-memo和useMemo的使用"><a href="#React-memo和useMemo的使用" class="headerlink" title="React.memo和useMemo的使用"></a>React.memo和useMemo的使用</h2><p>在React的class Component时代，为了性能优化我们经常使用<code>pureComponent + shouldComponentUpdate</code>对组件进行深层次的控制。</p><p>到了Funciton Component时代，React也提供了<code>memo</code>和<code>useMemo</code>，以达到<code>pureComponent + shouldComponentUpdate</code>同样效果。</p><h3 id="先看个例子："><a href="#先看个例子：" class="headerlink" title="先看个例子："></a>先看个例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, memo, useMemo &#125; from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">import &#123; Input &#125; from &#39;antd&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">export default class TestMemo extends Component &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  state &#x3D; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    firstName: &#39;x&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    lastName: &#39;f&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  handleChange(key, value) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    this.setState(&#123; [key]: value &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;render&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    const &#123; firstName, lastName &#125; &#x3D; this.state;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &lt;Input label&#x3D;&#39;姓&#39; value&#x3D;&#123;firstName&#125; onChange&#x3D;&#123;e &#x3D;&gt; this.handleChange(&#39;firstName&#39;, e.target.value)&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &lt;Input label&#x3D;&#39;名&#39; value&#x3D;&#123;lastName&#125; onChange&#x3D;&#123;e &#x3D;&gt; this.handleChange(&#39;lastName&#39;, e.target.value)&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &lt;FristName name&#x3D;&#123;firstName&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &lt;LastName name&#x3D;&#123;lastName&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      &lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">function FristName(&#123;name&#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render firstName&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">function LastName(&#123;name&#125;) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render lastName&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>仔细分析上面的例子，不难发现，每次在父组件的两个Input输入框任意一个中输入值，两个子组件<code>FristName</code>和<code>LastName</code>都会跟着渲染，即使跟子组件并不相关的props更新了，也渲染了一遍。<code>理论上，父组件每次变化一个 state 都通过 props 传递给了子组件，那子组件就会重新执行渲染。（无论子组件有没有真正用到这个 props）</code>，这无疑是浪费的渲染。</p><h3 id="使用memo"><a href="#使用memo" class="headerlink" title="使用memo"></a>使用memo</h3><p>下面我们使用memo对<code>FirstName</code>组件进行改造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import &#123; memo &#125; from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">const propsAreEqual &#x3D; function(prevProps, nextProps) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return prevProps.name &#x3D;&#x3D;&#x3D; nextProps;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const FristName &#x3D; memo((&#123;name&#125;) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render firstName&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;, propsAreEqual);</span></pre></td></tr></table></figure><p>使用了memo改造之后，我们会发现，当改变firstName后，<code>FirstName</code>组件会跟着渲染，而当改变lastName后，在控制台里可以看到<code>render firstName</code>并没有打印，说明<code>FirstName</code>组件并没有渲染，达到了性能优化的目的。</p><h3 id="使用useMemo"><a href="#使用useMemo" class="headerlink" title="使用useMemo"></a>使用useMemo</h3><p>看上面说那个memo的例子，我们发现React.memo是需要包裹整个组件的，并且需要手动写一个方法比较那些具体的props不相同才进行re-render。</p><p>而在某些场景下，我们只是希望component的某些部分不要进行re-render，而不是整个component编剧要re-render，也就是需要局部pure的功能。</p><p><code>useMemo</code>是React自带的hooks API，基本用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import &#123; useMemo &#125; from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">const memoizedValue &#x3D; useMemo(memoizedFunction(), [memoizedParams]);</span></pre></td></tr></table></figure><p>useMemo()返回的是一个memoized值，只有当依赖项memoizedParams发生改变，才会重新调用memoizedFunction函数计算生成新的memoizedValue。memoizedParams不变时不会触发memoizedFunction函数。</p><p>需要注意的是：<code>useMemo是在render期间执行的，所以不能进行一些副作用操作，比如网络请求等。</code></p><p>如果没有提供依赖项即memoizedParams，则每次都会调用memoizedFunction函数计算memoizedValue。</p><p>回到我们的例子，我们希望只有当lastName发生改变时，才会去重新渲染LastName组件，即用useMemo包裹return部分渲染的逻辑，下面是使用useMemo改造后的LastName组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function FristName(&#123;name&#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render firstName out useMemo&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return useMemo(() &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;render firstName in useMemo&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;, [name]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>再次运行时，我们会发现，<code>render firstName out useMemo</code>一直会打印，当我们没有改变firstName时，在useMemo函数中的这句<code>render firstName in useMemo</code>并不会打印，只有改变了firstName的值时，才会打印。这就是useMemo<code>局部pure</code>的体现了。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack之tree shaking</title>
      <link href="/posts/42071/"/>
      <url>/posts/42071/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack之tree-shaking"><a href="#webpack之tree-shaking" class="headerlink" title="webpack之tree shaking"></a>webpack之tree shaking</h2><p>webpack从2.0开始引入tree shaking概念。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>先了解下webpack中几个相关概念：</p><ul><li><p>AST<br>AST对JS代码进行语法分析后得出的语法树（Abstract Syntax Tree）。AST语法树可以把一段JS代码的每一个语句转化成语法树中的一个节点。</p></li><li><p>DCE<br>Dead Code Elimination,在保持代码运行结果不变的前提下，去除无用的代码。这样的好处是：</p><ul><li>优化代码</li><li>减小程序体积</li><li>减少程序执行时间</li></ul><p>其中Dead Code指的是：</p><ul><li>程序中不会执行的代码（如不可能进入的分支，return之后的代码等）</li><li>写入变量之后不再读取的代码</li></ul></li></ul><p>tree shaking是 DCE 的一种方式，它可以在打包时忽略没有用到代码。</p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>首先需要知道webpack的运行机制：</p><ol><li><p>先使用babel-loader处理js文件</p><p> babel的配置文件中有一个preset配置项：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  preset: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    [&#39;env&#39;, &#123; &#39;module&#39;: false &#125;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p> 其中presets里的env有个module的配置项，设置为false，这是指示babel如何去处理impory和export等关键字，默认以require形式，设置为false则babel就不会把import，export转成require形式了，这也为webpack的tree shaking创造了条件。</p></li><li><p>然后webpack进行tree-shaking识别和记录，打包处理</p><p> <code>webpack在认定某块代码无用后，会再处理过程中写下一段注释。uplifyjs会根据这点注释去进行删除代码。</code></p><p> webpack负责对代码进行标记，把import&amp;export分为3类：</p><ul><li>所有import标记为 /* harmony import */ </li><li>被使用过的export标记为 /* harmony export([type]) */, 其中type和webpack有关，可能是binding，immutable等</li><li>没被使用过的import标记为 /* unused harmony export [FunctionName] */, 其中FunctionName即export的方法名称</li></ul></li><li><p>最后由uglifyjs根据webpack标识删除多余代码，进行代码压缩</p></li></ol><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>img标签的alt和title</title>
      <link href="/posts/8189/"/>
      <url>/posts/8189/</url>
      
        <content type="html"><![CDATA[<h2 id="img标签的alt和title属性"><a href="#img标签的alt和title属性" class="headerlink" title="img标签的alt和title属性"></a>img标签的alt和title属性</h2><p>在html的img标签中，有alt和title两个重要的属性。</p><h3 id="alt属性："><a href="#alt属性：" class="headerlink" title="alt属性："></a>alt属性：</h3><ul><li><p>如果图像没有下载或者加载失败，会用文字来代替图像显示。</p><p>  这一作用是为了给加载不出网页图片的用户提供图片信息，方便用户浏览网页，也方便维护网页。</p></li><li><p>搜索引擎可以通过这个属性的文字来抓取图片</p></li></ul><h3 id="title属性："><a href="#title属性：" class="headerlink" title="title属性："></a>title属性：</h3><ul><li>当网页上的图片被加载完成后，鼠标移动到上面去，会显示这个图片指定的属性文字，以对图片信息进行补充性说明。</li></ul>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object.freeze函数</title>
      <link href="/posts/3106097719/"/>
      <url>/posts/3106097719/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-freeze函数"><a href="#Object-freeze函数" class="headerlink" title="Object.freeze函数"></a>Object.freeze函数</h2><p>Object.freeze(),冻结函数，该方法用于冻结一个对象。<code>一个被冻结的对象将不能修改属性，删除已有属性或添加新的属性</code>。此外，<code>冻结一个对象之后，该对象的原型也不能被修改</code>。该方法的返回值为传入的对象。</p><p>看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; age: 18 &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Object.freeze(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">a.age &#x3D; 20;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">a.name &#x3D; &#39;zs&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">delete a.age; &#x2F;&#x2F; false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr></table></figure><p>同时冻结的对象的原型也不能被修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; age: 18 &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Object.freeze(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">var b &#x3D; a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">b.age &#x3D; 20;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">console.log(b); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr></table></figure><p>但是，Object.freeze()只是<code>浅冻结</code>，被冻结的对象并不总是不可变的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; name: &#123; firstName: &#39;zhang&#39; &#125; &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Object.freeze(a);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">a.name.firstName &#x3D; &#39;wang&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123; name: &#123; firstName: &quot;wang&quot; &#125; &#125;</span></pre></td></tr></table></figure><p>最后，需要注意的是，<code>只要freeze之后，就不能解除了</code>，所以使用这个API需要谨慎</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github Page 搭建个人博客（一）安装</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建个人博客的方式有很多种，大多数都需要从各种网上代理商上买域名和服务器部署自己的博客系统。本文介绍的是使用 <code>Hexo</code> + <code>Github Page</code>来搭建，这是一种搭建速度最快，完全免费开源，不需要购买任何服务器资源即可运行的方式，而且有 many many 种博客主题供你选择。下面先简单介绍下<code>Hexo</code> 和 <code>Github Page</code>：</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Hexo</code> 是基于Node.js驱动的一款静态博客框架，除了官方提供的很多种主题，github上也有很多开发者分享的开源的主题，都可供使用者自由选择，而且切换主题也相当简单方便。<code>Github Page</code> 是 Github 提供的 一种静态网页托管服务，可以用来托管博客等静态网页资源，关键是免费的！结合使用<code>Hexo</code> + <code>Github Page</code> 可以帮助我们快速搭建个人博客。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>， <code>Hexo</code> 是基于Node.js的，所以需要准备Node环境。</li><li>创建<a href="https://github.com/" target="_blank" rel="noopener">github</a> 账号</li><li>安装<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>，将本地项目打包后生成的静态资源文件上传到github上进行托管。</li></ol><h2 id="Github上创建个人仓库"><a href="#Github上创建个人仓库" class="headerlink" title="Github上创建个人仓库"></a>Github上创建个人仓库</h2><p>首先创建个人仓库，用来存放博客所需要的文件资源：</p><p><img alt="github仓库名" data-src="/posts/undefined/hexo_1.jpg" class="lazyload"></p><p>这时候我们的博客站点<code>http://用户名.github.io</code>就建好了！当然由于是个空项目，访问是空白的。下面我们将使用hexo来创建一个项目来部署我们的站点。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ol><li>我们需要先安装<code>hexo-cli</code>脚手架，脚手架可以帮助我们创建一个完整可用的项目。在本地打开一个cmd窗口运行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span></pre></td></tr></table></figure></li><li>然后使用hexo新建一个项目：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo init 新建项目文件名</span></pre></td></tr></table></figure></li><li>安装npm包依赖:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install</span></pre></td></tr></table></figure>这时候我们打开刚刚新建的项目文件夹，看下目录结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">项目根目录</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">├── node_modules</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">├── scaffolds # 模版文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">|   ├── _drafts # 草稿文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">|   └── _posts # 文章Markdowm文件 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">└── themes  # 主题文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">├── package.json</span></pre></td></tr></table></figure>这时我们运行<code>hexo s</code>命令启动工程，其中 s 是 server 的缩写：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo s</span></pre></td></tr></table></figure>启动成功后，在浏览器中输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 回车就可以预览效果了！<br><img alt="预览效果" data-src="/posts/undefined/hexo_2.jpg" class="lazyload"></li></ol><p>可能到此处你会觉得奇怪，我们什么都没做，怎么就生成这么好看的一套页面出来了！那这就要归功于<code>hexo-theme</code>了。每一种<code>hexo-theme</code>都内置了大量的样式文件，我们只需简单的配置就能打造出非常酷炫好看的博客网站！hexo中提供了非常多种theme，除此之外，github上也有大量开源的theme供我们自主选择，免费使用！</p><h2 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h2><p>本地hexo博客系统开发完毕后，我们还需要部署到我们前面在github上创建的个人仓库里才能通过站点访问到。 </p><p>在部署之前，第一步，先安装一个插件<code>hexo-deployer-git</code>，用于本地hexo项目连接到远程git仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span></pre></td></tr></table></figure><p>第二步，打开项目根目录下的_config.yml配置文件配置远程github仓库的参数。直接拉到_config.yml文件末尾，找到deploy选项，按如下配置：<br><img alt="github配置" data-src="/posts/undefined/hexo_3.jpg" class="lazyload"></p><p>最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo g -d</span></pre></td></tr></table></figure><p>稍等一会，在浏览器访问网址： <code>https://用户名.github.io</code> 就会看到你的博客啦！！</p><h2 id="搞定"><a href="#搞定" class="headerlink" title="搞定"></a>搞定</h2><p>至此，我们的个人博客网站就创建好了！后续还会对博客网站加入改进，努力打造出一个炫酷精致的博客网站！</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github Page 搭建个人博客（二）发布文章和url处理</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<p>前面我们已经搭建好了我们的博客网站，现在我们来发布新的文章吧！</p><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>新建文章，输入以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo new &#39;文章标题&#39;</span></pre></td></tr></table></figure><p>执行完成后，可以在根目录下/source</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to Panda-Wind&#39;s Blog</title>
      <link href="/posts/20593/"/>
      <url>/posts/20593/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://panda-wind.github.io/">Panda-Wind</a>! I will share some interesting things with you here.</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
