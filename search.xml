<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>事件冒泡、事件捕获和事件委托(事件代理)</title>
      <link href="/posts/3367743277/"/>
      <url>/posts/3367743277/</url>
      
        <content type="html"><![CDATA[<h2 id="事件冒泡、事件捕获和事件委托-事件代理"><a href="#事件冒泡、事件捕获和事件委托-事件代理" class="headerlink" title="事件冒泡、事件捕获和事件委托(事件代理)"></a>事件冒泡、事件捕获和事件委托(事件代理)</h2><p>事件冒泡和事件捕获是分别由微软和网景公司提出的，都是为了解决页面事件流（事件发生顺序）的问题。</p><p>比如有下面一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr></table></figure><p>上面一段代码描述的是一个div元素当中有一个p子元素，如果给这两个元素都加上点击事件，那么我们怎么知道哪一个函数会首先被触发呢？</p><p>为了解决这个问题， 微软和网景公司提出了两种完全相反的概念。</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>微软提出了名为事件冒泡的事件流。事件冒泡可以形象的比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面，也就是说，事件会从内层的元素开始发生，一直向上传播，直到顶层的document对象。</p><p>因此上面的例子中，在事件冒泡的概念下发生点击事件的顺序应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">p -&gt; div -&gt; body -&gt; html -&gt; document</span></pre></td></tr></table></figure><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>网景公司提出了另一种事件流，名为事件捕获。恰恰与事件冒泡相反，事件会从最外层开始发生，直到最里面的元素。</p><p>因此上面的例子中，在事件捕获的概念下发生点击事件的顺序应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">document -&gt; html -&gt; body -&gt; div -&gt; p</span></pre></td></tr></table></figure><h3 id="addEventListener的第三个参数"><a href="#addEventListener的第三个参数" class="headerlink" title="addEventListener的第三个参数"></a>addEventListener的第三个参数</h3><p><code>DOM2级事件</code>中规定的事件流同时支持了事件冒泡阶段和事件捕获阶段，作为开发者，我们可以选择事件处理函数在哪一个阶段被调用。</p><p><code>addEventListener</code>方法用来为一个特点的元素绑定一个事件处理函数，有三个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">element.addEventListener(event, <span class="function"><span class="keyword">function</span>, <span class="title">useCapture</span>);</span></span></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>event</td><td>必须。字符串，指定事件名</td></tr><tr><td>function</td><td>必须。指定事件触发时要执行的函数</td></tr><tr><td>useCapture</td><td>可选。布尔值，指定事件是在捕获阶段还是冒泡阶段执行。true表示捕获阶段，false表示冒泡阶段。默认为false。</td></tr></tbody></table><h3 id="事件委托-事件代理"><a href="#事件委托-事件代理" class="headerlink" title="事件委托(事件代理)"></a>事件委托(事件代理)</h3><p>利用事件流的特性，在开发中，我们可以使用一种事件委托(事件代理)的方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"color_list"</span>&gt;</span>        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>red<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>yellow<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>green<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>blue<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>purple<span class="tag">&lt;/<span class="name">li</span>&gt;</span>    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></pre></td></tr></table></figure><p>我们想要在点击每个li标签的时候，输出当前点击的li的颜色。</p><p>常规做法是变量每个li，然后在每个li上绑定一个点击事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color_list = <span class="built_in">document</span>.querySelector(<span class="string">'.color_list'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = color_list.getElementsByTagName(<span class="string">'li'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; colors.length; n++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  colors[n].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这种做法当li标签个数少的时候还可以使用，万一li的数量较多时，无疑会对性能造成影响。</p><p>利用事件流的特性，我们可以只在父元素ul标签上绑定一个事件处理函数就可以可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color_list = <span class="built_in">document</span>.querySelector(<span class="string">'.color_list'</span>); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">color_list.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event; <span class="comment">// 兼容性处理</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (e.target.nodeName.toLowerCase() === <span class="string">'li'</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(e.target.innerHTML);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>由于事件冒泡机制，点击了l后会冒泡到ul，此时就会触发绑定在ul上的点击事件，再利用event.target找到事件实际发生的元素，就可以达到预期的效果。</p><p>上面这种做法就是<code>事件委托(事件代理)</code>。</p><p>使用<code>事件委托(事件代理)</code>的好处不仅在于将多个事件处理函数减成一个，而且对于不用元素可以有不同的处理方法。假如上述列表元素当中添加了其他的元素节点(如span，a等)，我们不必再一次循环给每个元素绑定事件，直接修改事件代理的事件处理函数即可。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><p>冒泡还是捕获？</p><p>对于事件代理来说，在事件冒泡还是事件捕获阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件模型被所有主流浏览器兼容，从兼容性角度来说还是建议大家使用<code>事件冒泡</code>。</p></li><li><p>IE浏览器兼容</p><p>IE浏览器对<code>addEventlistener</code>兼容性并不好，只有IE9以上才支持。要兼容旧版本的IE浏览器，可以使用IE的<code>attachEvent函数</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">object.attachEvent(event, <span class="function"><span class="keyword">function</span>);</span></span></pre></td></tr></table></figure><p>两个参数和<code>addEventListener</code>相似，分别是事件和处理函数，默认是事件冒泡阶段调用处理函数。</p></li><li><p>阻止事件冒泡</p><p>(1) 给子元素加event.stopPropagation()</p><p>(2) 在事件处理函数中返回false。</p><p>2和1是有区别的。<code>return false</code>不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。<code>event.stopPropagation</code>则只阻止事件往上冒泡，不阻止事件本身。</p><p>(3) event.target === event.currentTarget，让事件触发的元素等于绑定事件的元素，也可以阻止事件冒泡。</p></li><li><p>阻止默认事件</p><p>(1) event.preventDefault()</p><p>(2) return false</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React合成事件</title>
      <link href="/posts/3640873551/"/>
      <url>/posts/3640873551/</url>
      
        <content type="html"><![CDATA[<h2 id="React合成事件"><a href="#React合成事件" class="headerlink" title="React合成事件"></a>React合成事件</h2><p><strong>一.前言</strong></p><p><strong><em>1.先想想几个问题</em></strong></p><ul><li>我们写的事件是绑定在 dom 上吗？如果不是那么事件绑定在哪里去了？</li><li>为什么我们的事件需要手动绑定 this ？（不是箭头函数的情况）</li><li>为什么不能用<code>return false</code>来阻止事件的默认行为？</li></ul><p><strong><em>2.我们在JSX中定义的事件最终会变成什么</em></strong></p><p>  下面是一段含有点击事件的JSX代码：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'handle click'</span>); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span>(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;按钮&lt;<span class="regexp">/button&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    )</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure><br>  经过 babel 转换后，代码变成这样：<br>  <img alt="1.jpg" data-src="/posts/3640873551/1.jpg" class="lazyload"></p><p>  接下来在浏览器中，看看<code>&lt;button&gt;</code>这个元素上有没有绑定 onClick 事件呢？<br>  <img alt="2.jpg" data-src="/posts/3640873551/2.jpg" class="lazyload"></p><p>  从上图中我们会发现，<code>button</code>上绑定了两个事件，一个是<code>document</code>上的事件监听器，另一个是<code>button</code>。而<code>button</code>上的没有看到我们的<code>handleClick</code>事件, 而是<code>handle</code>。而且这个<code>handle</code>指向的是一个空函数。<br>  <img alt="3.jpg" data-src="/posts/3640873551/3.jpg" class="lazyload"></p><p>  接着再看<code>document</code>绑定事件：<br>  <img alt="4.jpg" data-src="/posts/3640873551/4.jpg" class="lazyload"></p><p>  可以看到 click 事件被绑定到<code>document</code>上了。</p><p>  所以我们可以得出结论：  </p><ul><li>我们在 jsx 中绑定的事件根本没有注册到真是的 dom上，而是采用<code>事件冒泡</code>的形式冒泡到document上面，然后 react 将事件封装到正式的函数处理。</li><li>真实 dom 上的 click 事件被 react 底层处理成空函数了。</li><li>react 并不是一开始把所有的事件都绑定在 document上，而是采取了一种按需绑定的策略了，比如发下了 onClick 事件，再去绑定 document click 事件。</li></ul><p><strong>二. 合成事件</strong></p><p>在 react 中，我们绑定的事件如 <code>onClick</code> 等，都不是原生事件，而是由原生事件合成的 react 事件，比如 <code>click</code> 事件合成为 <code>onClick</code> 事件，<code>blur</code>、 <code>change</code>、 <code>input</code>、<code>keydown</code> 等合成为 <code>onChange</code>。</p><p>那么为什么 react 要采用这种事件合成模式呢？</p><ol><li>减少内存消耗，提高性能。一种事件类型只在 document 上注册一次，不需要注册那么多次事件了。如果 DOM 上绑定了过多的事件处理函数，整个页面的响应速度以及内存占用可能都会受到影响。</li><li>统一规范，兼容各个浏览器。</li></ol><p>那么 react 是如何处理事件合成的呢？</p><p>下面从三个部分来解析：</p><ol><li>react 对事件是如何合成的。</li><li>react 事件是怎么绑定的。</li><li>react 事件触发流程。</li></ol><p><strong>三. 事件初始化</strong></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程 (process) 和线程 (thread)</title>
      <link href="/posts/158612386/"/>
      <url>/posts/158612386/</url>
      
        <content type="html"><![CDATA[<h2 id="进程-process-和线程-thread"><a href="#进程-process-和线程-thread" class="headerlink" title="进程 (process) 和线程 (thread)"></a>进程 (process) 和线程 (thread)</h2><p>进程和线程是操作系统的基本概念。</p><p><strong><em>1. 概念</em></strong></p><p>进程是CPU资源分配的最小单位（是拥有资源和独立运行的最小单位）。<br>线程是CPU调度的最小单位（是建立在进程上的一次程序运行单位）。</p><p><strong><em>2. 举例</em></strong></p><p>对于浏览器来说，打开一个Word就是打开一个进程，Word支持同时进打字、拼写检查、打印等事情。在一个进程内部要做多件事情，就需要同时运行多个子任务，这些子任务就叫做<code>线程</code>。</p><p>由于一个进程内部至少要做一件事情，所以<code>一个进程至少有一个线程</code>。系统会给每个进程分配独立的内存，因此进程有它独立的资源。同一进程内的各个线程之间共享该进程的内存空间。</p><p>用一个生动的比喻来说，进程就是一像一个有边界的生产厂间，而线程就像厂间内的一个个员工，可以自己做自己的事情，也可以相互配合做同一件事情。</p><p>当我们启用一个应用时，计算机会创建一个进程，操作系统会为进程分配一部分内存，应用的所有状态都会保存在这块内存中。</p><p>应用也许会创建多个线程来辅助工作，这些进程可以共享这部分内存中的数据，如果应用关闭，进程会被关闭，操作系统会释放相关内存。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中==和===的原理</title>
      <link href="/posts/1570400975/"/>
      <url>/posts/1570400975/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript中-和-的原理"><a href="#JavaScript中-和-的原理" class="headerlink" title="JavaScript中==和===的原理"></a>JavaScript中==和===的原理</h2><h3 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a>运算规则</h3><p>在比较之前，==的两个操作符都会进行强制类型转换，== 和 != 都遵循以下准则:</p><ol><li>如果有一个操作符是布尔值，咋在比较相等性之前会先将其转换为数值，即调用Number()函数.</li><li>如果有一个操作符是字符串，另一个是数值时，在比较相等性之前会先将字符串转换为数组，即调用Number()函数.</li><li>如果有一个操作符是对象类型，另一个是原始类型，则会先将对象转换为原始类型再进行相等性比较，对象转原始类型按照以下流程运行：  <blockquote><p>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数，其逻辑如下：  </p><ol><li>如果有Symbol.toPrimitive()方法，优先调用并返回</li><li>调用valueOf()，如果转换为原始类型，则返回</li><li>调用toString()，如果转换为原始类型，则返回</li><li>如果都没有返回原始类型，会报错</li><li>js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。</li></ol></blockquote></li></ol><p>以上是类型转换时遵循的原则，在转换成基本数据类型以后，会出现两边都是同个类型或不同类型的情况，在进行比较时又遵循以下原则：  </p><ol><li>null和undefined是相等的，这是js规定的，但其实在底层，undefined是派生自null的，所以逻辑等时要返回true.</li><li>如果有个操作数是NaN，则返回false(NaN不与任何操作符逻辑等或全等，包括自身). </li><li>如果两个操作符都是对象，则比较它们是不是同一个对象，是则返回true.</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol><li><p>[] == ![]的结果为什么是true？  </p><blockquote><ol><li>首先<code>[]</code>是数组不是原始类型，先通过<code>valueOf -&gt; toString</code>的顺序转换成<code>&quot;&quot;</code>空字符串。</li><li>js中，对于空数组<code>[]</code>在进行逻辑判断时都会返回true。<code>![]</code>就返回false了。false在逻辑判断时会通过Number函数转换成0。</li><li>运算符左侧是空字符串，右侧是数字0，根据运算准则，会将空字符串通过Number函数转成数字0。</li><li>最后0==0成立，返回true。</li></ol></blockquote></li><li><p>如何让a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3结果为true？  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 设置默认值为0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  value: 0,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 复写valueOf方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  valueOf() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F; 每次自增，让value慢慢增加</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      this.value++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      return this.value;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">console.log(a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3);&#x2F;&#x2F;true</span></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/posts/3632233996/"/>
      <url>/posts/3632233996/</url>
      
        <content type="html"><![CDATA[<h1 id="SRM工作流使用文档"><a href="#SRM工作流使用文档" class="headerlink" title="SRM工作流使用文档"></a>SRM工作流使用文档</h1><h2 id="1-功能列表"><a href="#1-功能列表" class="headerlink" title="1. 功能列表"></a>1. 功能列表</h2><p>工作流模块是为了实现采购、合同、对账等企业业务操作流程审批自动化、智能化而设置的。其包括了SRM对于权限的控制，企业用户对于工作流的设置，是否任务会签审批，流程审批者动态指定，根据不同流程函告涉及到业务信息指示，前往不同流程任务节点，用户任务的审批方式，加签，转交，抄送，邮件审批等一系列，来达到企业定制化的审批流程。</p><style type="text/css" rel="stylesheet">.table-area {   overflow-x: scroll;}th, td {    padding: 6px;    min-width: 50px;}</style>  <div class="table-area">    <table>        <thead>            <tr>                <th>功能菜单</th>                <th>说明</th>              <th>所需角色</th>                <th>备注</th>            </tr>        </thead>        <tbody>            <tr>                <td>流程分类</td>                <td>流程分类是按照业务节点进行区分；</td>                <td>租户管理员</td>                <td></td>            </tr>            <tr>                <td>流程单据</td>                <td>流程单据配置审批表单、邮件审批、单据关联的流程变量等；</td>                <td>租户管理员</td>                <td></td>            </tr>            <tr>                <td>接口定义</td>                <td>配置查找审批人员规则、节点跳转方式、审批方式等等</td>                <td>租户管理员</td>              <td></td>            </tr>          <tr>                <td>服务定义</td>                <td>关联接口定义，可配置接口所需参数与流程变量的映射关系（包含工作流引擎内置的流程变量）</td>                <td>租户管理员</td>            <td></td>            </tr>          <tr>                <td>流程定义</td>                <td>图形化编辑工作流的审批链，单据的流转方式、具体审批人员等</td>                <td>租户管理员</td>            <td></td>            </tr>          <tr>                <td>流程指定</td>                <td>实现根据公司/订单类型/变更类型…等不同变量，个性化启动工作流</td>                <td>租户管理员</td>            <td></td>            </tr>          <tr>                <td>流程启动</td>                <td>输入参数手工启动工作流，用于开发测试流程部署后，是否可以走通流程；</td>                <td>租户管理员</td>                    <td>该菜单仅用于测试流程，不能用于正式环境</td>            </tr>          <tr>                <td>流程监控</td>                <td>监控启动的所有工作流，可恢复流程、终止流程。在流程审批报错后，可通过流程监控查看问题原因；</td>                <td>租户管理员</td>            <td></td>            </tr>          <tr>                <td>流程转交</td>                <td>查询出当前租户下所有审批中的流程，可将指定流程转交至指定人，可用于员工离职且改员工下挂有待办事项的情况；</td>                <td>租户管理员</td>                    <td>通常用于处理已离职员工下的待办事项</td>            <td></td>            </tr>          <tr>                <td>我的待办事项</td>                <td>当前员工待办理的审批事项；</td>                <td>有此菜单权限的角色</td>            <td></td>            </tr>          <tr>                <td>我发起的流程</td>                <td>当前员工发起的所有流程；</td>                <td>有此菜单权限的角色</td>                    <td>只能查询到当前登录系统员工发起的工作流审批，包含已结束与未结束的</td>            </tr>          <tr>                <td>我参与的流程</td>                <td>包含我的待办事项、我发起的流程中的所有流程，已结束与未结束均可查询到；</td>                <td>有此菜单权限的角色</td>            <td></td>            </tr>          <tr>                <td>我的抄送流程</td>                <td>抄送到当前的员工的审批流程，只能查看抄送过来的流程；</td>                <td>有此菜单权限的角色</td>            <td></td>            </tr>          <tr>                <td>自动转交设置</td>                <td>员工可配置一段时间内，所有待审批流程转到其他员工进行审批；</td>                <td>有此菜单权限的角色</td>            <td></td>            </tr>          <tr>                <td>自动处理规则</td>                <td>可配置指定流程需要本人审批时自动同意或自动转交到指定人，配置规则有超时时间和固定时间；</td>                <td>有此菜单权限的角色</td>            <td></td>            </tr>        </tbody>    </table></div><h2 id="2-工作流配置"><a href="#2-工作流配置" class="headerlink" title="2. 工作流配置"></a>2. 工作流配置</h2><h3 id="2-1-流程分类"><a href="#2-1-流程分类" class="headerlink" title="2.1. 流程分类"></a>2.1. 流程分类</h3><p>最小业务节点的分类。例如，送货单审批、送货单复审，为两个业务节点；</p><p><img alt="流程分类列表" data-src="images/%E6%B5%81%E7%A8%8B%E5%88%86%E7%B1%BB%E5%88%97%E8%A1%A8.png" class="lazyload"></p><p>预定义：SRM平台定义，所有租户只能查看，不能删除与编辑；</p><p>自定义：当预定义流程分类不满足需求时，租户自定义新建的；</p><h4 id="2-1-1-流程分类维护"><a href="#2-1-1-流程分类维护" class="headerlink" title="2.1.1.流程分类维护"></a>2.1.1.流程分类维护</h4><ul><li>点击<code>新建</code>，进入流程分类新建界面；</li></ul><p><img alt="新建流程分类" data-src="images/%E6%96%B0%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E7%B1%BB.png" class="lazyload"></p><blockquote><ul><li>一个流程分类可关联多个流程单据；</li><li>流程单据非必输；</li></ul></blockquote><ul><li>新增流程单据、添加流程变量；    </li></ul><p><img alt="新建流程分类" data-src="images/%E6%96%B0%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E7%B1%BB-%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F.png" class="lazyload"></p><blockquote><p><code>流程变量</code>中的字段名称和字段类型需要对应业务模块技术人员告知；</p></blockquote><h4 id="2-1-2-配置说明"><a href="#2-1-2-配置说明" class="headerlink" title="2.1.2.配置说明"></a>2.1.2.配置说明</h4><style type="text/css" rel="stylesheet">.table-area {   overflow-x: scroll;}th, td {    padding: 6px;    min-width: 50px;}</style><div class="table-area">    <table>        <thead>            <tr>                <th>字段</th>                <th>必输</th>              <th>含义</th>            </tr>        </thead>        <tbody>            <tr>                <td>流程分类编码</td>                <td>Y</td>                <td>当前租户下编码唯一</td>            </tr>            <tr>                <td>启用</td>                <td>N</td>                <td>默认启用</td>            </tr>            <tr>                <td>流程单据</td>                <td>N</td>                <td>可配置多个流程单据，非必填</td>            </tr>          <tr>                <td>流程变量</td>                <td>N</td>                <td>流程流转过程中使用的变量。在流程启动时，将会携带流程分类指定的变量值在流程运转中应用，如流程分类，定义了采购需求金额变量，所有这个分类下的流程都可以使用这个作为采购需求金额的变量进行使用；`字段类型`分为 `数字`、 `字符串`、 `布尔值`；`是否必输`表示流程启动时客户端该字段是否必传；</td>        </tr></tbody>    </table></div><h3 id="2-2-流程单据"><a href="#2-2-流程单据" class="headerlink" title="2.2. 流程单据"></a>2.2. 流程单据</h3><p>流程中所使用的业务单据，包含审批时所需的审批表单配置，邮件审批时所需的邮件审批配置；</p><p><img alt="流程单据列表" data-src="images/%E6%B5%81%E7%A8%8B%E5%8D%95%E6%8D%AE%E5%88%97%E8%A1%A8.png" class="lazyload"></p><p>预定义：SRM平台定义的，所有租户只能查看，不能删除与编辑；</p><p>自定义：预定义的不满足业务需求时，当前租户新建的；</p><p>点击 <code>编辑</code>，可查看平台定义的，用于租户定义流程单据时，作为参考；</p><h4 id="2-2-1-维护流程单据"><a href="#2-2-1-维护流程单据" class="headerlink" title="2.2.1.维护流程单据"></a>2.2.1.维护流程单据</h4><ul><li>点击<code>新建</code>，进入新建界面；</li></ul><p><img alt="新建流程单据" data-src="images/%E6%96%B0%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%8D%95%E6%8D%AE.png" class="lazyload"></p><p>​配置流程单据编码、流程单据描述及所属的流程分类，默认启用；</p><blockquote><ul><li>一个单据可关联多个流程分类；</li><li>流程分类非必输；</li></ul></blockquote><ul><li>维护流程变量</li></ul><p><img alt="流程单据-流程变量" data-src="images/%E6%B5%81%E7%A8%8B%E5%8D%95%E6%8D%AE-%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F.png" class="lazyload"></p><p>​        此处定义的流程变量需要在启动工作流时由业务服务传入，工作流根据此处的<code>是否必输</code>校验启动参数，通常用于<code>服务定义</code>;</p><ul><li>维护流程表单</li></ul><p><img alt="流程单据-流程表单" data-src="images/%E6%B5%81%E7%A8%8B%E5%8D%95%E6%8D%AE-%E6%B5%81%E7%A8%8B%E8%A1%A8%E5%8D%95.png" class="lazyload"></p><p>同一单据可维护多个流程表单，用于不同节点的使用，可实现同一流程不同节点查看的流程表单不同；</p><blockquote><ul><li><p>审批表单的展示界面需每个模块技术单独开发；</p></li><li><p>一般情况下，流程表单都是只读，仅用于展示单据数据，PC 端表单 URL 必须以 <code>relative://</code> 作为前缀，表示此 URL 为相对路径；</p></li><li><p>若需配置可修改或需校验数据的审批表单，PC 端表单 URL 必须以 <code>include://</code> 作为前缀，<br>并且审批表单前端代码需提供用于校验或修改数据的相应函数，使用此方式在审批时如果报错会引发事务问题；</p></li></ul></blockquote><ul><li><p>流程表单前端配置  </p><ol><li>在前端路由文件中添加流程表单页面的路由配置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">## 路由文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  path: &#39;&#x2F;pub&#x2F;sfin&#x2F;approve-form&#39;, &#x2F;&#x2F; 流程表单页面的url</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  authorized: true, &#x2F;&#x2F; 必加，用于pub路由的访问</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  models: [() &#x3D;&gt; import(&#39;..&#x2F;models&#x2F;sfin&#x2F;modelB.js&#39;)], &#x2F;&#x2F;流程表单页面用到的model</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  component: () &#x3D;&gt; import(&#39;..&#x2F;routes&#x2F;sfin&#x2F;ComponentA&#39;), &#x2F;&#x2F;流程表单页面组件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;,</span></pre></td></tr></table></figure></li><li>若前端是微前端模式，则需要在前端模块根目录下的<code>hzerorc.js</code>中添加<code>hwfp</code>路由的配置。<br><img alt="流程单据-流程表单" data-src="images/%E6%B5%81%E7%A8%8B%E8%A1%A8%E5%8D%95-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE.png" class="lazyload"></li><li>若PC端表单URL以<code>include://</code>作为前缀，则需要在前端模块下的<code>src</code>目录下新建<code>customize</code>目录，添加<code>index.js</code>，用作流程表单的配置文件,参照以下方式配置流程表单。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">## src&#x2F;customize&#x2F;index.js</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入 存储 卡片配置的方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">import &#123; setWorkflowApproveForm &#125; from &#39;hzero-front&#x2F;lib&#x2F;customize&#x2F;workflowApproveForm&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入 加载 model 的包装方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">import &#123; dynamicWrapper &#125; from &#39;..&#x2F;utils&#x2F;router&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置 编码为 SFIN.APPROVE_FORM_A 的 流程表单</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">setWorkflowApproveForm(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  code: &#39;SFIN.APPROVE_FORM_A&#39;, &#x2F;&#x2F; 流程单据内配置的流程单据编码</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  component: async () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    return dynamicWrapper(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      window.dvaApp,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      [&#39;sfin&#x2F;modelA&#39;, &#39;sfin&#x2F;modelB&#39;], &#x2F;&#x2F; 流程表单页面用到的model</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      () &#x3D;&gt; import(&#39;..&#x2F;routes&#x2F;sfin&#x2F;ComponentA&#39;) &#x2F;&#x2F; 流程表单页面组件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 配置多个setWorkflowApproveForm即可配置多个流程表单</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">setWorkflowApproveForm(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  code: &#39;SFIN.APPROVE_FORM_B&#39;, &#x2F;&#x2F; 流程单据内配置的流程单据编码</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  component: async () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    return dynamicWrapper(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      window.dvaApp,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">      [&#39;sfin&#x2F;modelC&#39;, &#39;sfin&#x2F;modelD&#39;], &#x2F;&#x2F; 页面用到的model</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">      () &#x3D;&gt; import(&#39;..&#x2F;routes&#x2F;sfin&#x2F;ComponentB&#39;) &#x2F;&#x2F; 页面组件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure></li><li>若PC端表单URL以<code>include://</code>作为前缀，需要流程表单页面前端代码提供回调函数，用于工作流审批页面点击审批按钮时进行回调，同时工作流审批页面会将审批结果以字符串形式传递给流程表单页面。相关实现方法请参照如下方式调整前端代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">## 流程表单页面组件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">export default class App &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 在componentDidMount中注册submit回调函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  componentDidMount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 从props中解构出onLoad函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    const &#123; onLoad &#125; &#x3D; this.props;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 使用onLoad函数注册submit回调函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    onLoad(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      submit: this.submit,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  &#x2F;**</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  * submit回调函数用于工作流审批页面点击审批按钮时进行回调</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  * </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  * @param &#123;string&#125; approveResult | 工作流审批页面的审批结果, Approved - 审批同意, Rejected - 审批拒绝</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  submit(approveResult) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; submit函数需返回一个Promise对象</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">      ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ol></li><li><p>维护邮件审批表单</p></li></ul><p>邮件审批表单，用于邮件审批待办事项，邮件的内容多以展示业务单据为主，便于审批人员进行审批；</p><p>以下为演示视频：</p><video id="video" width="720" height="400" controls>      <source src="https://storage.going-link.com/video/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E9%82%AE%E4%BB%B6%E5%AE%A1%E6%89%B9.mp4"></video><p>以下为文字介绍：</p><p><img alt="邮件审批表单维护" data-src="images/%E9%82%AE%E4%BB%B6%E5%AE%A1%E6%89%B9%E8%A1%A8%E5%8D%95%E7%BB%B4%E6%8A%A4.png" class="lazyload"></p><blockquote><p>目前邮件审批由于邮件客户端有兼容性问题，已验证以下邮件客户端：</p><ul><li>网易邮箱大师（移动版）</li><li>Mac系统自带邮件客户端</li><li>FoxMail</li></ul></blockquote><p> <strong>数据来源</strong>：（非必输字段）</p><p>作用于数据渲染，调用服务获取数据信息， 如果模版内容需要数据渲染，以表达式进行渲染，如${json.prNum} prNum 为数据来源接口返回字段，json为后台默认的数据别名。</p><p> <strong>模版内容</strong></p><p>html 代码，用于邮件审批节点发送的邮件内容。</p><blockquote><ul><li>只须编写需要在邮件中展示的前端代码即可，如关联的订单数据;</li><li>若需要使用当前流程的流程变量，则须从 <code>procVar</code> 中获取；</li><li>若<code>模版内容</code>中需使用<code>数据来源</code>中的数据，则需从 <code>json</code> 中获取；</li><li>由于不同的客户端对 html 的编写要求不一，需要技术人员自行查询编写要求；</li></ul></blockquote><p> <strong>如何使用</strong></p><ul><li>如下图，在人工节点点击<code>邮件审批表单</code>即可选择当前流程定义关联的流程单据配置的邮件审批模版；</li></ul><p><img alt="人工节点选择邮件模版" data-src="images/%E4%BA%BA%E5%B7%A5%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9%E9%82%AE%E4%BB%B6%E6%A8%A1%E7%89%88.png" class="lazyload"></p><ul><li><p>部署流程流程定义后即可生效；</p></li><li><p>触发该节点时，当前节点的审批人会收到如下图所示邮件。点击<code>同意</code>或<code>拒绝</code>后并输入审批意见，发送邮件即可；</p></li></ul><p><img alt="邮件审批表单效果图" data-src="images/%E9%82%AE%E4%BB%B6%E5%AE%A1%E6%89%B9%E8%A1%A8%E5%8D%95%E6%95%88%E6%9E%9C%E5%9B%BE.png" class="lazyload"></p><p><img alt="邮件审批回复" data-src="images/%E9%82%AE%E4%BB%B6%E5%AE%A1%E6%89%B9%E5%9B%9E%E5%A4%8D.png" class="lazyload"></p><ul><li>工作流在平台级定义了调度任务，会定时拉去邮件服务器数据，解析邮件审批相关邮件数据完成流程审批；</li></ul><blockquote><p>调度任务：工作流邮件审批任务(HWFP.MAIL_APPROVE_JOB)，执行周期为10分钟；</p></blockquote><h3 id="2-3-接口定义"><a href="#2-3-接口定义" class="headerlink" title="2.3. 接口定义"></a>2.3. 接口定义</h3><p>主要用于新建<code>远程调用</code>类型的<code>服务定义</code>使用；</p><p><img alt="接口定义列表" data-src="images/%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E5%88%97%E8%A1%A8.png" class="lazyload"></p><p>预定义：SRM平台创建的接口定义；</p><p>自定义：针对当前租户创建的接口定义；</p><blockquote><p>接口定义对应的服务接口需保证幂等，即接口多次执行，执行结果一致；</p></blockquote><h4 id="2-3-1-维护接口定义"><a href="#2-3-1-维护接口定义" class="headerlink" title="2.3.1.维护接口定义"></a>2.3.1.维护接口定义</h4><ul><li>新建接口定义</li></ul><p><img alt="新建接口定义" data-src="images/%E6%96%B0%E5%BB%BA%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89.png" class="lazyload"></p><table><thead><tr><th>字段</th><th>必输</th><th>含义</th></tr></thead><tbody><tr><td>接口编码</td><td>Y</td><td>租户下唯一</td></tr><tr><td>服务名称</td><td>Y</td><td>可选集成于 SRM 产品的所有服务</td></tr><tr><td>接口权限编码</td><td>Y</td><td>值集，可选择服务名称配置的服务的接口；</td></tr><tr><td>接口说明</td><td>N</td><td>默认使用服务接口的描述</td></tr><tr><td>启用</td><td>Y</td><td>默认启用</td></tr></tbody></table><ul><li>维护参数</li></ul><p><img alt="接口定义-参数" data-src="images/%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89-%E5%8F%82%E6%95%B0.png" class="lazyload"></p><table><thead><tr><th>字段</th><th>必输</th><th>含义</th></tr></thead><tbody><tr><td>参数名称</td><td>Y</td><td>接口所需参数的名称</td></tr><tr><td>参数类型</td><td>Y</td><td>接口参数类型，目前仅支持 <code>数字</code>、<code>字符串</code>、<code>布尔值</code>三种类型</td></tr><tr><td>参数描述</td><td>N</td><td>参数描述，非必输列</td></tr><tr><td>默认值</td><td>N</td><td>流程变量中不存在该字段时使用此配置，不建议使用，非必输列</td></tr></tbody></table><blockquote><ul><li><p>新建接口定义前需保证使用的接口已开发完成并将接口权限刷新到 <code>iam_permission</code> 表；</p></li><li><p>在<code>接口定义</code>和<code>参数</code>维护完成后，可使用右上方的<code>测试</code>按钮测试接口是否正常；</p></li></ul></blockquote><h3 id="2-4-服务定义"><a href="#2-4-服务定义" class="headerlink" title="2.4. 服务定义"></a>2.4. 服务定义</h3><p>服务定义用于流程定义的审批方式、审批规则、服务任务、监听器等；</p><p><img alt="服务定义列表" data-src="images/%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%B9%89%E5%88%97%E8%A1%A8.png" class="lazyload"></p><p>预定义：SRM平台创建的服务定义，仅支持查看；</p><p>自定义：针对当前租户创建的服务定义，可编辑、删除；</p><h4 id="2-4-1-维护服务定义"><a href="#2-4-1-维护服务定义" class="headerlink" title="2.4.1.维护服务定义"></a>2.4.1.维护服务定义</h4><p><img alt="新建服务定义" data-src="images/%E6%96%B0%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%B9%89.png" class="lazyload"></p><p>流程分类：改服务定义关联的流程分类，服务定义在具体的流程分类下，只有当前分类下可以使用定义的服务任务；</p><p>服务编码：租户下编码唯一；</p><p>服务方式：目前支持<code>远程调用</code>、<code>表达式</code>、<code>值集视图</code>三种方式；</p><blockquote><ul><li><p>远程调用</p><p>必须选择对应的<code>接口定义</code>，适用于较为复杂的逻辑，如通过订单上的采购品类查找对应的采购员进行审批、审批通过            后将单据审批状态改写、订单更改原始订单审批过程自动终止等；</p></li><li><p>表达式</p><p>流程变量之间通过操作符来完成校验判断，返回值为 <code>TRUE</code> 或 <code>FLASE</code>，多应用于跳转条件，支持复杂的逻辑判断。</p></li><li><p>值集视图</p><p>目前仅用于 <code>审批规则</code>，只能使用关联的值集为 <code>URL</code> 类型的值集视图，</p></li></ul></blockquote><p>服务方式：目前支持<code>审批方式</code>、<code>跳转条件</code>、<code>审批规则</code>、<code>服务任务</code>四种方式；</p><blockquote><ul><li><p>审批方式</p><p>对应人工节点中的审批方式配置项；</p></li><li><p>审批规则</p><p>对应人工节点中的审批规则配置项；</p><p>如果审批规则为远程调用，接口返回结果不能返回 <code>null</code>;</p></li><li><p>跳转条件</p><p>对应连接线上的跳转条件配置项；</p></li><li><p>服务任务</p><p>对应流程定义中的服务任务节点；</p></li></ul></blockquote><p>流程单据：该服务定义需要关联的流程单据，非必输项；</p><blockquote><p>配置后在维护<code>参数</code>时可选择到该流程单据中配置的<code>流程变量</code>，用于配置<code>参数</code>与<code>流程变量</code>的映射关系；</p></blockquote><p>服务描述：必输项；</p><h4 id="2-4-2-维护参数"><a href="#2-4-2-维护参数" class="headerlink" title="2.4.2.维护参数"></a>2.4.2.维护参数</h4><ul><li><p>远程调用</p><p>在选择完接口定义后会自动填充该配置，仅需配置其与流程变量的映射关系即可；</p></li><li><p>表达式</p><p>需配置执行表达式和参数相应的判断逻辑；</p></li></ul><p><img alt="服务定义-表达式" data-src="images/%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%B9%89-%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" class="lazyload"></p><p>表达式：可按照参数的序号来写，通过 ()、&amp;&amp;、 || 等符号连接多个参数判断。点击参数可选择该流程分类下的所有参数，可以参数与常量判断，也可参数与变量进行判断；</p><p>审批结果表达式：配置方式同 <code>表达式</code>一致，但仅用于<code>审批方式</code>，用于在离开当前人工节点时计算审批结果，通常用于在流程结束时业务服务通过审批结果来修改业务单据状态；</p><blockquote><p>例如，如上图的审批方式，表达式为 <code>nrOfRejected &gt; 0</code> ，则审批结果表达式可配置为 <code>nrOfApproved == nrOfInstances</code> ，表示若 <code>同意总数等于审批总数</code>，则审批结果为 Approved (审批同意)，反之为 Rejected (审批拒绝)；</p></blockquote><p>序号：服务定义中的表达式配置项，若使用表达式中的数字，需同<code>表达式</code>一致；</p><blockquote><p>例如，上图中 <code>prType == &#39;TypeA&#39;</code>，在左边的表达式中就是 <code>2</code>，所以在 <code>参数</code> 配置中序号即位 2；</p></blockquote><p>左参数来源、有参数来源：目前支持<code>常量</code>、<code>流程变量</code>两种类型;</p><p>左参数值、右参数值：参数来源为<code>流程变量</code>时，可选择到当前<code>服务定义</code>关联的<code>流程分类</code>和<code>流程单据</code>中配置的所有的<code>流程变量</code>；</p><p>运算符：左参数与右参数的判断条件；</p><h4 id="2-4-3-流程变量介绍"><a href="#2-4-3-流程变量介绍" class="headerlink" title="2.4.3.流程变量介绍"></a>2.4.3.流程变量介绍</h4><table><thead><tr><th>参数名称</th><th>含义</th></tr></thead><tbody><tr><td>initiator</td><td>流程发起人</td></tr><tr><td>approveResult</td><td>审批结果，默认为最后一个审批人的审批结果</td></tr><tr><td>nrOfApproved</td><td>当前人工节点同意次数</td></tr><tr><td>nrOfRejected</td><td>当前人工节点拒绝次数</td></tr><tr><td>nrOfInstances</td><td>当前人工节点可审批次数</td></tr><tr><td>wflNum</td><td>审批方式变量，在审批方式为 <code>一定比例</code> 时使用，值在 <code>0～1</code> 之间</td></tr><tr><td>organizationId</td><td>租户标识</td></tr><tr><td>assignee</td><td>当前审批人</td></tr><tr><td>processName</td><td>流程名称</td></tr><tr><td>processDescription</td><td>流程描述</td></tr><tr><td>historyApprovers</td><td>流程历史审批人，包含之前审批过的所有人，没有去重，以逗号隔开</td></tr><tr><td>processInstanceBusinessKey</td><td>业务主键</td></tr><tr><td>contextArgs</td><td>消息模板参数，包含当前流程的所有流程变量，Map转Json</td></tr><tr><td>processInstanceStartTime</td><td>流程申请时间</td></tr><tr><td>processInstanceId</td><td>流程标识</td></tr><tr><td>previousApprover</td><td>上一节点审批人,多个审批人以英文逗号分隔</td></tr><tr><td>comment</td><td>当前审批人的审批意见</td></tr></tbody></table><blockquote><p>以上为工作流引擎内置的流程变量，若需要其他的流程变量联系工作流服务的负责人；</p><p>业务上的流程变量需要在对应的流程分类或流程单据中定义；</p></blockquote><h3 id="2-5-流程定义"><a href="#2-5-流程定义" class="headerlink" title="2.5. 流程定义"></a>2.5. 流程定义</h3><p>根据流程分类与流程单据，定义具体的审批流程；</p><p><img alt="流程定义列表" data-src="images/%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E5%88%97%E8%A1%A8.png" class="lazyload"></p><blockquote><ul><li><p>预定义的流程<code>不能编辑</code>、 <code>不能部署</code>，可以下载、复制并查看进行参考；</p></li><li><p>自定义的流程，可以编辑，在使用前需要<code>部署</code>才可以生效，每部署一次就会生成一个新的版本，各个版本之间互不影响，暂不支持恢复到之前的某个版本；</p></li><li><p>对于已存在的流程定义，仅能在编辑流程定义后再次查询后才能部署；</p></li><li><p>流程定义编辑器中使用的服务定义仅能查询到 <code>当前流程定义关联的流程分类</code> 及 <code>默认流程分类</code> 的服务定义；</p></li></ul></blockquote><h4 id="2-5-1-维护流程定义"><a href="#2-5-1-维护流程定义" class="headerlink" title="2.5.1.维护流程定义"></a>2.5.1.维护流程定义</h4><ul><li><p>维护方式</p><p><code>导入</code>、 <code>新建</code>、 <code>复制</code></p><ul><li><p>导入</p><p><img alt="流程定义-导入" data-src="images/%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89-%E5%AF%BC%E5%85%A5.png" class="lazyload"></p><blockquote><ul><li><p>导入的文件必须满足 <code>BPMN 2.0</code> 规范，否则导入报错；</p></li><li><p>流程编码<code>当前租户下唯一</code>，若已存在<code>相同编码</code>的流程，导入时会进行<code>覆盖</code>，覆盖时会校验<code>流程分类</code>和<code>流程单据</code>是否一致，不一致会直接抛错；</p></li><li><p><code>超时时间</code> 用于在待办超过配置的时间后提醒审批人进行审批使用，默认禁用；</p></li></ul></blockquote></li><li><p>新建<br><img alt="流程定义-新建" data-src="images/%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89-%E6%96%B0%E5%BB%BA.png" class="lazyload"></p><p>手动新建流程定义同导入基本一致，无需选择文件;</p></li><li><p>复制</p><p><img alt="流程定义-复制" data-src="images/%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89-%E5%A4%8D%E5%88%B6.png" class="lazyload"></p><p>如上图点击复制即可；</p><blockquote><p>目前复制后的流程定义不能将预定义流程定义中的节点配置同步过来，之后会优化该功能并支持此操作；</p></blockquote></li></ul></li><li><p>部署记录</p></li></ul><p><img alt="流程定义-部署记录" data-src="images/%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89-%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95.png" class="lazyload"></p><p>主要用于将流程发起时间同发布记录时间比较来判断此流程处于那个版本；</p><ul><li>下载</li></ul><p><img alt="流程定义-下载" data-src="images/%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89-%E4%B8%8B%E8%BD%BD.png" class="lazyload"></p><p>下载即将已配置完成的流程定义导出为 <code>BPMN文件</code>，可用于各个环境间流程定义的迁移，简化配置时间；</p><blockquote><p>目前 <code>DEV</code> 环境导出的 <code>BMPN文件</code>会包含流程定义节点上所有的配置项，可同<code>导入</code>功能配合使用；</p></blockquote><ul><li>超时时间配置</li></ul><p><img alt="流程定义-超时时间" data-src="images/%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89-%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4.png" class="lazyload"></p><p>用于该流程的待办超时未审批时通知审批人进行审批，超时时间单位目前仅支持<code>小时</code>、<code>天</code>，默认关闭；</p><h4 id="2-5-2-流程定义节点配置详解"><a href="#2-5-2-流程定义节点配置详解" class="headerlink" title="2.5.2.流程定义节点配置详解"></a>2.5.2.流程定义节点配置详解</h4><ul><li>编辑器界面介绍</li></ul><p><img alt="流程定义-编辑器" data-src="images/%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89-%E7%BC%96%E8%BE%91%E5%99%A8.png" class="lazyload"></p><ul><li><p>开始节点</p><p>标志流程开始，有且仅有一个开始节点，存在多个时，则在部署流程时报错 ；</p></li></ul><p><img alt="开始节点" data-src="images/%E5%BC%80%E5%A7%8B%E8%8A%82%E7%82%B9.png" class="lazyload"></p><p>名称：审批中显示的节点名称；</p><p>流程表单：即当前流程定义关联的<code>流程单据</code>中配置的<code>所有流程表单</code>，用于在待办办理界面展示<code>业务单据</code>使用，在<code>我发起的流程</code>、<code>我参与的流程</code>、<code>流程监控</code>等菜单中会使用此节点中配置的流程表单；</p><p>合并审批历史：用于将当前流程（未结束）的审批记录与相同 <code>businessKey</code> 的流程（已结束）的审批历史合并，默认关闭；</p><p>自行审批时自动同意：启用时，若当前人工任务的 <code>审批人</code>包含 <code>流程申请人</code>，则 <code>自动审批（审批同意）</code>，默认关闭；</p><p>监听器：展示当前流程关联的流程分类下所有服务方式为远程调用的服务定义，类型分为 <code>开始</code>和 <code>撤销</code>;</p><blockquote><p>执行时期：</p><ul><li><p>开始</p><p>流程发起时触发</p></li><li><p>撤销</p><p><code>我发起的流程</code>中点击<code>撤销</code>按钮s时、<code>流程监控</code>中点击<code>终止流程</code>时</p></li></ul></blockquote><p>表单属性：主要记录其他配置项的配置，业务人员可忽略此选项；</p><ul><li><p>人工任务</p><p>一般的业务流程大多都会有人的参与，因此人工任务就是最常用的任务，当流程到达人工任务时，人工任务会被分配到特定的用户；</p><blockquote><p>在部署流程定义时，默认会给人工任务添加一个<code>审批拒绝的跳转线</code>，指向<code>结束节点</code>；</p></blockquote></li></ul><p><img alt="人工节点" data-src="images/%E4%BA%BA%E5%B7%A5%E8%8A%82%E7%82%B9.png" class="lazyload"></p><p>名称：审批中显示的节点名称，例如，采购总监审批等；</p><p>审批方式：流程离开当前人工任务流转到下个节点的<code>判断条件</code>；</p><blockquote><ul><li><p>工作流默认提供<code>任一人</code>、<code>全部通过</code>、<code>一定比列</code>、<code>一票通过或拒绝</code>四种，默认为<code>任一人</code>;</p></li><li><p>审批方式通常为<code>表达式类型</code>的服务定义，也支持使用<code>远程调用</code>类型的服务定义；</p></li></ul></blockquote><p>审批方式变量：若审批方式为<code>一定义比例</code>时使用，其他审批方式均无效，需要配置为 <code>小数</code>。例如，当前节点审批人为5人，需要3人审批通过才能流转到下个节点，即可配置为 <code>0.6</code>，表示60%，旁边的加减按钮以 <code>0.1</code>递增或递减；</p><p>审批规则：用于获取当前节点的审批人列表，通常为远程调用类型的服务定义；</p><blockquote><p>工作流默认提供<code>申请者自己</code>、<code>指定人</code>、<code>指定岗位</code>等，当默认审批规则不满足需求时，在服务定义中创建即可；</p></blockquote><p>自动抄送：流程流转到该节点时需要抄送的员工列表，通常为远程调用类型的服务定义；</p><blockquote><p>工作流默认提供<code>申请者自己</code>、<code>指定人</code>、<code>指定岗位</code> 等，当默认审批规则不满足需求时，在服务定义中创建即可；</p></blockquote><p>审批动作配置：待办办理界面可展示的审批按钮，目前支持<code>审批同意</code>、<code>审批拒绝</code>、<code>转交</code>、<code>加签</code>、<code>驳回</code>五种按钮；</p><blockquote><ul><li><p>所有按钮都可点击旁边的 <code>铅笔</code> 图形 <code>自定义</code> 按钮名称；</p></li><li><p>因为第一个人工节点无需且无法驳回（包括转交后），所以即使勾选驳回按钮也不会展示；</p></li><li><p>加签后仅展示<code>审批同意</code>和<code>审批拒绝</code>按钮；</p></li></ul></blockquote><p>审批意见标题：用于自定义待办办理界面中审批意见标题；</p><p><img alt="审批意见" data-src="images/%E5%AE%A1%E6%89%B9%E6%84%8F%E8%A7%81.png" class="lazyload"></p><blockquote><p>用户审批待办输入审批意见，但还未审批并关闭当前Tab页时，工作流会保存之前输入的审批意见，便于再次审批；</p></blockquote><p>审批同意审批意见必输：用于待办审批点击审批通过时校验审批意见是否必输；</p><p>拒绝后通知审批人：在审批人拒绝人工任务时通知申请人（邮件+站内消息）；</p><blockquote><p>多人审批时，若多人审批拒绝则会多次通知申请人；</p></blockquote><p>已审批自动同意：若当前节点的审批人在之前已审批过其他节点，则自动审批（审批同意）；</p><p>允许撤回：启用时表示当前流程流转到该节点时可撤回，默认启用；</p><p>允许催办：启用时表示当前流程流转到该节点时可通过在 <code>我发起的流程</code> 中提醒审批人审批（站内消息），默认启用；</p><blockquote><p>24小时内仅能催办一次；</p></blockquote><p>流程表单：即当前流程定义关联的<code>流程单据</code>中配置的<code>所有流程表单</code>，不同人工任务节点可配置不同的审批表单，人工任务节点的流程表单仅用于<code>待办办理界面</code>使用；</p><p>邮件审批表单：当前流程关联的流程单据中配置的邮件审批表单，用于审批人通过邮件办理待办；</p><p>监听器：展示当前流程关联的流程分类下所有服务方式为远程调用的服务定义，类型分为 <code>创建</code>、 <code>分配</code>、 <code>完成</code>、 <code>删除</code>；</p><blockquote><p>执行时期：</p><p>创建：创建人工任务时</p><p>分配：给人工任务设置审批人时</p><p>完成：审批人办理待办事项时</p><p>删除：审批人办理待办事项后，工作流引擎删除人工任务时</p><p>在使用时，建议使用<code>分配</code>和<code>完成</code>两种类型；</p></blockquote><p>表单属性：主要记录其他配置项的配置，业务人员可忽略此选项；</p><ul><li><p>服务任务</p><p>该节点类似于人工任务中的监听器，用于远程调用业务服务接口，执行相关业务逻辑，仅能使用<code>远程调用</code>类型的服务定义；</p></li></ul><p><img alt="服务任务" data-src="images/%E6%9C%8D%E5%8A%A1%E4%BB%BB%E5%8A%A1.png" class="lazyload"></p><p>名称：当前节点名称；</p><p>异步：勾选后将异步执行，不会阻塞当前流程，默认禁用；</p><blockquote><p>不建议启用该选项，由于是异步执行，若服务任务执行报错流程将不会挂起，业务服务可能会存在脏数据；</p></blockquote><p>服务任务：选择<code>远程调用</code>类型的服务定义；</p><ul><li><p>结束节点</p><p>标示流程结束的节点，位于整个流程的最后，同一个流程可配置多个该节点；</p></li></ul><p><img alt="结束节点" data-src="images/%E7%BB%93%E6%9D%9F%E8%8A%82%E7%82%B9.png" class="lazyload"></p><p>名称：当前节点名称；</p><p>监听器：展示当前流程关联的流程分类下所有服务方式为远程调用的服务定义，仅有<code>结束</code>类型；</p><blockquote><p>执行时期：</p><p>结束：流程结束时</p></blockquote><ul><li><p>跳转线</p><p>用于连接流程中的每个节点，通过 <code>跳转条件</code> 控制流程走向；</p></li></ul><p><img alt="跳转线" data-src="images/%E8%B7%B3%E8%BD%AC%E7%BA%BF.png" class="lazyload"></p><p>名称：跳转线名称；</p><p>跳转条件：用于控制流程走向，多使用<code>表达式</code>类型的服务定义，亦可使用<code>远程调用</code>类型的服务定义；</p><blockquote><ul><li>当使用远程调用类型的服务定义时，接口的返回结果必须是<code>布尔值</code>，即 <code>true</code> 或 <code>false</code>；</li><li>不配置时默认为审批同意；</li></ul></blockquote><p>默认跳线：启用时，若当前节点的所有跳转线都不满足条件时，流程流转的方向；</p><blockquote><ul><li>启用时不能配置跳转条件；</li></ul></blockquote><ul><li><p>单一网关</p><p>用于连接跳转线，美化流程图，无实际作用；</p></li></ul><ul><li><p>并行网关</p><p>审批任务并行处理，配置时，需要在并行 <code>开始前</code> 与 <code>之后</code> 均增加并行网关；</p><p>并行网关开始和结束之间可使用上述所有节点，除<code>开始</code>和 <code>结束</code> 外；</p></li></ul><ul><li>流程图展示</li></ul><p><img alt="流程图展示" data-src="images/%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%B1%95%E7%A4%BA.png" class="lazyload"></p><blockquote><p>节点的跳转线若有 <code>多条</code>，需配置 <code>跳转条件</code>，且所有跳转线的跳转条件需 <code>满足所有情况</code>，否则在审批该节点时会报错，可配置一条 <code>默认跳线</code>避免该情况；</p></blockquote><h3 id="2-6-流程指定"><a href="#2-6-流程指定" class="headerlink" title="2.6. 流程指定"></a>2.6. 流程指定</h3><p>流程启动时，根据流程变量与流程单据 找到多条流程，通过流程指定，可以满足业务中对订单的审批支持根据订单类型、公司等变量不同，使用不同的流程进行审批。（功能启用工作流审批，通过流程分类+单据启动）</p><h4 id="2-6-1-新建流程指定"><a href="#2-6-1-新建流程指定" class="headerlink" title="2.6.1.新建流程指定"></a>2.6.1.新建流程指定</h4><p><img alt="流程指定列表" data-src="images/%E6%B5%81%E7%A8%8B%E6%8C%87%E5%AE%9A%E5%88%97%E8%A1%A8.png" class="lazyload"></p><p>​    点击 <code>新建</code>，选择 <code>流程分类</code>及 <code>流程单据</code> 即可，相关描述在配置后会自动填充；</p><h4 id="2-6-2-变量配置"><a href="#2-6-2-变量配置" class="headerlink" title="2.6.2.变量配置"></a>2.6.2.变量配置</h4><p>选择流程分类与流程单据中的流程变量，配置需要通过哪个变量进行判断，<code>规则配置</code> 中使用此处配置的变量；</p><p><img alt="流程指定-变量配置" data-src="images/%E6%B5%81%E7%A8%8B%E6%8C%87%E5%AE%9A-%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE.png" class="lazyload"></p><p>序号：数字，不可重复，表明该字段生效的优先级，数字越大，优先级越高；</p><p>变量名称：流程单据及流程分类中配置的流程变量名称；</p><p>变量描述：变量名称选择后自动填充；</p><p>字段类型：支持 <code>文本框</code>、 <code>LOV</code>、 <code>数字</code> 、 <code>下拉框</code>;</p><p>数据来源：字段类型选择 <code>LOV</code> 与 <code>下拉框</code> 时，该配置项为选择对应的值集；</p><p>宽度：数字，表示当前变量在 <code>规则配置</code> 中的列宽；</p><h4 id="2-6-3-规则配置"><a href="#2-6-3-规则配置" class="headerlink" title="2.6.3.规则配置"></a>2.6.3.规则配置</h4><p>根据流程指定 <code>变量配置</code> 转置成表格的列字段，配置具体变量的值对应的审批流程；</p><p>例如，变量配置如下：</p><p><img alt="流程指定-变量配置列子" data-src="images/%E6%B5%81%E7%A8%8B%E6%8C%87%E5%AE%9A-%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E5%88%97%E5%AD%90.png" class="lazyload"></p><p>则规则配置界面如下：</p><p><img alt="流程指定-规则配置" data-src="images/%E6%B5%81%E7%A8%8B%E6%8C%87%E5%AE%9A-%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE.png" class="lazyload"></p><p>流程：选择当前流程分类及流程单据下流程定义；</p><p>默认流程发起人：在业务服务启动工作流时未设置流程发起人，则使用此配置，值为员工编码；</p><blockquote><ul><li><p>若在启动时需指定流程发起人，可设置此属性 <code>org.srm.workflow.api.dto.ProcessStartDTO#specifyUserId</code>，字段类型为Long；</p></li><li><p>优先级：specifyUserId &gt; 当前登陆用户 &gt; 规则配置的默认流程发起人；</p></li></ul></blockquote><h4 id="2-6-4-流程指定执行规则"><a href="#2-6-4-流程指定执行规则" class="headerlink" title="2.6.4.流程指定执行规则"></a>2.6.4.流程指定执行规则</h4><ol><li><p>流程启动传过来参数和流程规则里配置的值，选择匹配上的数量最多的一条；</p></li><li><p>匹配上多条规则，则选择匹配上的规则里变量优先级高的审批流程；</p></li><li><p>匹配数量相同，且优先级相同，则随机取一条审批流；</p></li><li><p>当变量值均匹配不上时，若存在变量值均为空的规则，则选择该条流程；反之无空白值且匹配不上，流程指定启动报错；</p></li></ol><p>例如，变量流程变量配置中配置了4个变量，第一个变量为公司、第二个为业务实体、第三个为采购组织、第四个为来源系统；流程指定配置有如下数据：</p><table><thead><tr><th>序号</th><th>公司</th><th>业务实体</th><th>采购组织</th><th>来源系统</th><th>流程</th><th>默认流程发起人</th></tr></thead><tbody><tr><td>1</td><td>上海甄云</td><td>SAP A.G.</td><td>采购组织001</td><td>SRM</td><td>流程A</td><td>账户a</td></tr><tr><td>2</td><td>上海甄云</td><td>SAP A.G.</td><td></td><td></td><td>流程B</td><td>账户b</td></tr><tr><td>3</td><td></td><td>SAP A.G.</td><td></td><td>SRM</td><td>流程C</td><td>账户c</td></tr><tr><td>4</td><td>上海甄云</td><td>SAP A.G.</td><td></td><td></td><td>流程D</td><td>账户d</td></tr><tr><td>5</td><td></td><td></td><td></td><td></td><td>流程E</td><td>账户d</td></tr></tbody></table><p>流程A字段值最多，最优先匹配，若匹配上选择流程A；</p><p>当某笔单据同时匹配上流程B、C、D变量值匹配数量相同，但变量【公司】较【业务实体】靠前，因为从流程B、D选择，流程B、D两个优先级均一致，所以随机选择一条；</p><p>流程E的变量值均为空，为默认流程，其优先级最低，当以上均未匹配时，选择该流程。</p><blockquote><p>在部署流程定义时，默认会给人工任务添加一个<code>审批拒绝的跳转线</code>，指向<code>结束节点</code>；</p><p><img alt="流程指定-规则配置-默认" data-src="images/%E6%B5%81%E7%A8%8B%E6%8C%87%E5%AE%9A-%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE-%E9%BB%98%E8%AE%A4.png" class="lazyload"></p></blockquote><h3 id="2-7-流程监控"><a href="#2-7-流程监控" class="headerlink" title="2.7. 流程监控"></a>2.7. 流程监控</h3><p>流程监控用户管理员查看流程是否正常运行，排查流程运营的错误，如未找到审批人，执行监听器报错等；</p><p><img alt="流程监控列表" data-src="images/%E6%B5%81%E7%A8%8B%E7%9B%91%E6%8E%A7%E5%88%97%E8%A1%A8.png" class="lazyload"></p><p>对于挂起的流程，可根据报错原因不同，进行恢复流程、终止流程、指定审批人等操作；</p><p>具体的报错信息可点击 <code>异常信息</code> 查看；</p><h3 id="2-8-流程启动"><a href="#2-8-流程启动" class="headerlink" title="2.8. 流程启动"></a>2.8. 流程启动</h3><p>用于快速测试流程定义配置是否正确；</p><p><img alt="流程启动" data-src="images/%E6%B5%81%E7%A8%8B%E5%90%AF%E5%8A%A8.png" class="lazyload"></p><p>模拟用户：即流程发起人，非必填，默认当前用户；</p><p>业务主键：即 businessKey；</p><p>流程定义：LOV，可选择 <code>当前租户</code> 下 <code>已部署</code> 的所有流程定义；</p><p>参数：当前流程定义关联的流程分类及流程单据中配置的流程变量，在选择流程定义后会自动带出，此处需要填写必输的参数，否则启动           时报错；</p><p>在配置好之后点击 <code>启动</code> 按钮即可触发一条工作流；</p><blockquote><p>该菜单不使用 <code>流程指定</code> 配置;</p></blockquote><h3 id="2-9-流程转交"><a href="#2-9-流程转交" class="headerlink" title="2.9. 流程转交"></a>2.9. 流程转交</h3><p>主要用于将已离职员工下的待办事项转交至指定人审批；</p><p><img alt="流程转交列表" data-src="images/%E6%B5%81%E7%A8%8B%E8%BD%AC%E4%BA%A4%E5%88%97%E8%A1%A8.png" class="lazyload"></p><p><img alt="流程转交-选择转交人" data-src="images/%E6%B5%81%E7%A8%8B%E8%BD%AC%E4%BA%A4-%E9%80%89%E6%8B%A9%E8%BD%AC%E4%BA%A4%E4%BA%BA.png" class="lazyload"></p><p>勾选需要转交处理的流程后，点击右上角的 <code>转交</code> 按钮，选择转交人，点击 <code>确定</code> 即可；</p><blockquote><ul><li><p>此列表仅查询出当前租户下审批状态为 <code>审批中</code> 的流程；</p></li><li><p><code>当前处理人</code> 查询条件可查询出所有员工，包含 <code>已离职</code>或 <code>已禁用</code>的员工；</p></li><li><p><code>转交人</code> 仅能查出当前租户下启用的员工；</p></li></ul></blockquote><h3 id="2-10-公司级流程监控"><a href="#2-10-公司级流程监控" class="headerlink" title="2.10. 公司级流程监控"></a>2.10. 公司级流程监控</h3><p>同 <code>流程监控</code> 菜单作用一致，不过仅能查询出当前用户所在公司（当前租户下）的所有流程；</p><h2 id="3-我的工作流"><a href="#3-我的工作流" class="headerlink" title="3.我的工作流"></a>3.我的工作流</h2><h3 id="3-1-我的待办事项"><a href="#3-1-我的待办事项" class="headerlink" title="3.1.我的待办事项"></a>3.1.我的待办事项</h3><p>用户登录系统使用工作流，列出当前员工等待处理的流程，点击 <code>办理</code> 会打开待办详情进行审批。</p><p>同时也会在工作台展示，待办理的工作流，可点击进入审批界面；</p><p><img alt="我的待办事项-工作台" data-src="images/%E6%88%91%E7%9A%84%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9-%E5%B7%A5%E4%BD%9C%E5%8F%B0.png" class="lazyload"></p><p><img alt="我的待办事项列表" data-src="images/%E6%88%91%E7%9A%84%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9%E5%88%97%E8%A1%A8.png" class="lazyload"></p><p>点击“办理”进入详情界面。办理详情界面，包含工作流审批事项、审批表单、审批历史及审批流程图；</p><p><img alt="待办详情" data-src="images/%E5%BE%85%E5%8A%9E%E8%AF%A6%E6%83%85.png" class="lazyload"></p><p><img alt="待办详情-审批记录" data-src="images/%E5%BE%85%E5%8A%9E%E8%AF%A6%E6%83%85-%E5%AE%A1%E6%89%B9%E8%AE%B0%E5%BD%95.png" class="lazyload"></p><blockquote><ul><li><p>当前审批人可将流程抄送给其他员工（会过滤当前审批人），每个人工审批节点都是可以抄送；</p></li><li><p>指定审批人：下一个人工任务节点为多人审批，且审批规则为 <code>任一人</code>，展示下一个节点配置的所有人员，当前结点可以选择多个员工；</p></li><li><p>上传附件：审批时用户可根据需要上传附件，用于审批，之后节点的审批人均可下载并浏览此附件；</p></li><li><p>最下方的审批按钮为流程定义 <code>人工任务</code>节点中配置的，若当前待办是通过 <code>加签</code>或 <code>同意并加签</code> 生成的，则进显示 <code>审批通过</code>及 <code>审批拒绝</code>；</p></li><li><p>若当前流程关联的 <code>业务单据</code> 之前 <code>已触发过工作流</code>，则审批界面就会显示 <code>审批历史Tab页</code>。当流程定义的 <code>开始节点</code>勾选了 <code>合并审批历史</code>，则此处会将审批记录和审批历史 <code>合并</code>；</p></li><li><p>若下一节点的审批规则为 <code>上一审批人指定</code>，在 <code>审批通过</code>或 <code>审批拒绝</code>时会校验是否 <code>选择指定审批人</code>；</p></li></ul></blockquote><h3 id="3-2-我发起的流程"><a href="#3-2-我发起的流程" class="headerlink" title="3.2. 我发起的流程"></a>3.2. 我发起的流程</h3><p>仅能查询出当前用户发起的所有流程，包含所有状态；</p><p><img alt="我发起的流程列表" data-src="images/%E6%88%91%E5%8F%91%E8%B5%B7%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%97%E8%A1%A8.png" class="lazyload"></p><p><img alt="我发起的流程详情" data-src="images/%E6%88%91%E5%8F%91%E8%B5%B7%E7%9A%84%E6%B5%81%E7%A8%8B%E8%AF%A6%E6%83%85.png" class="lazyload"></p><blockquote><ul><li><p>撤销：该按钮仅在当前流程发起后 <code>无一人审批过</code>时展示，亦可进入 <code>详情</code> 点击 <code>撤销</code>，撤销后会执行 <code>开始节点撤销类型</code>的监听器；</p></li><li><p>催办：审批中的流程均可展示此按钮，24小时内仅能催办一次；</p></li></ul></blockquote><h3 id="3-3-我参与的流程"><a href="#3-3-我参与的流程" class="headerlink" title="3.3. 我参与的流程"></a>3.3. 我参与的流程</h3><p>可查询出当前用户处理过的所有流程，包含所有状态；</p><h3 id="3-4-我的抄送流程"><a href="#3-4-我的抄送流程" class="headerlink" title="3.4. 我的抄送流程"></a>3.4. 我的抄送流程</h3><p>展示流程审批过程中，其他用户审批时抄送给当前用户的事项；</p><h3 id="3-5-自动处理规则"><a href="#3-5-自动处理规则" class="headerlink" title="3.5. 自动处理规则"></a>3.5. 自动处理规则</h3><p>当前用户因休假或其他原因无法审批待办时，可针对某一流程定义在固定时间或额定时间内未审批时设置自动同意或自动转交；</p><p><img alt="自动处理规则列表" data-src="images/%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%E8%A7%84%E5%88%99%E5%88%97%E8%A1%A8.png" class="lazyload"></p><p>输入查询条件找到需要配置的流程定义；</p><p><img alt="自动处理规则-配置界面" data-src="images/%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%E8%A7%84%E5%88%99-%E9%85%8D%E7%BD%AE%E7%95%8C%E9%9D%A2.png" class="lazyload"></p><blockquote><ul><li><p>处理条件分为 <code>固定时间</code> 及 <code>超时时间</code>，若为固定时间需配置 <code>结束时间</code>， <code>开始时间非必填</code>，默认为 <code>当天的 00:00:00</code>；若为超时时间需设置 <code>超时时间</code>，时间单位仅支持 <code>小时</code>、 <code>天</code> 、 <code>周</code>；</p></li><li><p>处理规则分为 <code>自动转交</code> 及 <code>自动同意</code>，若为自动转交时需设置 <code>转交人</code>，若为自动同意，可设置 <code>审批意见</code>（非必输）；</p></li></ul></blockquote><h2 id="4-常见错误整理"><a href="#4-常见错误整理" class="headerlink" title="4.常见错误整理"></a>4.常见错误整理</h2><h3 id="4-1-流程定义部署报错"><a href="#4-1-流程定义部署报错" class="headerlink" title="4.1.流程定义部署报错"></a>4.1.流程定义部署报错</h3><ul><li><p><img alt="image-20200710153456381" data-src="images/image-20200710153456381-2509078.png" class="lazyload"></p></li></ul><p><strong>报错原因：</strong><br>    没有配置流程图；</p><p><strong>解决方法：</strong><br>    进入编辑器，配置流程图即可；</p><ul><li><p><img alt="image-20200710154009482" data-src="images/image-20200710154009482.png" class="lazyload"></p></li></ul><p><img alt="image-20201012212716571.png" data-src="images/image-20201012212716571.png" class="lazyload"></p><p><strong>报错原因：</strong><br>    流程图中节点跳转线没有正确连接到下个节点；</p><p><strong>解决方法：</strong><br>    进入编辑器，修改流程图即可，点击跳转线，只有两端全部显示绿色才连接正确；</p><h3 id="4-2-待办审批报错"><a href="#4-2-待办审批报错" class="headerlink" title="4.2.待办审批报错"></a>4.2.待办审批报错</h3><ul><li><p><img alt="image-20200710154427380" data-src="images/image-20200710154427380.png" class="lazyload"></p></li></ul><p><strong>报错原因：</strong></p><p>​    执行当前节点所有跳转线的跳转条件时，没有一个满足条件，导致工作流引擎无法判断流程走向；</p><blockquote><p>报错信息也可能是：<code>No outgoing sequence flow of the exclusive gateway &#39;sid-B75CE0D6-AF25-4C6F-BC23-2F8FCCDCDC6C&#39; could be selected for continuing the process</code></p></blockquote><p><strong>解决方法：</strong></p><p>​    根据业务场景重新配置节点的连出线，若配置了跳转条件，则需保证所有的跳转条件满足所有可能出现的情况；</p><p>​    可配置一条默认跳线（默认跳线不能配置跳转条件）；</p><ul><li><p><img alt="image-20200710155149258" data-src="images/image-20200710155149258.png" class="lazyload"></p></li></ul><p><strong>报错原因：</strong></p><p>​    该报错指当前节点已经挂起，不能进行审批；</p><blockquote><p>在出现该报错之前一定出现其他报错导致当前流程被挂起，可在<code>流程监控</code>中查看 <code>异常信息</code> 获取原始报错信息；</p></blockquote><p><strong>解决方法：</strong></p><p>​    出现这种情况通常是执行监听器报错，先联系对应模块技术，通过<code>流程监控</code>的异常信息或者日志平台查看具体报错，通过报错信息都能得到对应的服务定义编码；</p><ul><li><p><img alt="image-20200710162839428.png" data-src="images/image-20200710162839428.png" class="lazyload"></p></li></ul><p><strong>报错原因：</strong></p><p>​    执行人工任务的监听器或者服务任务报错；</p><p><strong>解决方法：</strong></p><p>​    异常信息中会打印出具体报错的服务定义编码和记录报错时间，之后通过查看对应服务的日志确定具体报错；</p><ul><li><p><img alt="image-20200710163352512" data-src="images/image-20200710163352512.png" class="lazyload"></p></li></ul><p><strong>报错原因：</strong></p><p>​    流程变量中不存在<code>totalPrice</code>变量；</p><p><strong>解决办法：</strong></p><p>​    若该变量是启动工作流时传递的变量，请检查业务服务启动工作流代码；</p><p>​    若是在流程流转过程中通过监听器返回并保存在流程变量中，请检查对应监听器接口代码；</p><ul><li>审批报错，查看日志发现出现问题的跳转条件或者监听器在当前的流程定义中并没有配置；</li></ul><p><strong>报错原因：</strong></p><p>​    当前运行中的流程定义版本不是最新版本；</p><p>​    例如，流程定义 <code>SCEC.PRODUCT_APPROVAL_SHELF</code> 在版本 <code>1</code> 中配置的跳转条件有问题，之后修改并重新部署，版本号为  <code>2</code>；</p><p>​    在重新部署之前，已经有人使用版本 <code>1</code> 触发了工作流，之后审批报错；</p><p><strong>解决方法：</strong></p><p>​    若在改流程的开始节点配置了<code>撤销类型</code>的监听器，可通过<code>流程监控</code>的<code>终止流程</code>按钮改写单据状态；</p><p>​    若没有配置，则无法处理这种情况，关联单据只能作废；</p><h3 id="4-3-触发工作流报错"><a href="#4-3-触发工作流报错" class="headerlink" title="4.3.触发工作流报错"></a>4.3.触发工作流报错</h3><ul><li><p><img alt="image-20200710162113179.png" data-src="images/image-20200710162113179.png" class="lazyload"></p></li></ul><p><strong>报错原因：</strong></p><p>​    通常为通过流程指定配置没有匹配到一条流程；</p><p><strong>解决方法：</strong></p><p>​    可查看工作流日志确定具体的报错原因；</p><p>​    检查流程指定配置是否正确；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/posts/1376120437/"/>
      <url>/posts/1376120437/</url>
      
        <content type="html"><![CDATA[<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>  React的生命周期从广义上分为三个阶段：挂载、渲染、卸载:</p><ol><li>挂载卸载过程<br>1.1 constructor()<br>1.2 componentWillMount()<br>1.3.componentDidMount()<br>1.4.componentWillUnmount ()  </li><li>更新过程<br>2.1. componentWillReceiveProps (nextProps)<br>2.2.shouldComponentUpdate(nextProps,nextState)<br>2.3.componentWillUpdate (nextProps,nextState)<br>2.4.componentDidUpdate(prevProps,prevState, snapshot)<br>2.5.render()   </li><li>React新增的生命周期(个人补充)<br>3.1. getDerivedStateFromProps(nextProps, prevState)<br>3.2. getSnapshotBeforeUpdate(prevProps, prevState)  </li></ol><h3 id="1-2-为什么对某些生命周期函数称为UNSAFE"><a href="#1-2-为什么对某些生命周期函数称为UNSAFE" class="headerlink" title="1.2 为什么对某些生命周期函数称为UNSAFE"></a>1.2 为什么对某些生命周期函数称为UNSAFE</h3><p>  自从react更新到16.3版本后，以前使用的 componentWillMount、 componentWillReceiveProps、 componentWillUpdate三个生命周期函数都有eslint报警，让我们使用 UNSAFE_前缀的新的生命周期函数，这也是为了提醒开发者，这些生命周期函数是有缺陷的。  </p><ol><li><p>componentWillMount<br>componentWillMount生命周期发生在首次渲染前，如果在此处进行初始化数据或异步获取外部数据，一旦过程中出现异常，错误，会导致页面直接渲染不出来。</p></li><li><p>componentWillReceiveProps<br>compoenntWillReceiveProps是在props发生变化时触发，一般用于props参数更新时同步更新state。但如果在此处调用父组件的某些有调用setState函数，则会让程序陷入死循环，导致崩溃。</p></li><li><p>componentWillUpdate<br>componentWillUpdate和componentDidUpdate这两个生命周期有一定的时间差。componentWillUpdate后经过渲染，计算，再更新Dom元素，最后才调用componentDidUpdate。如果在componentWillUpdate中调用setState，可能会出现多次调用只更新一次的问题。</p></li></ol><h3 id="1-3-getDerivedStateFromProps和getSnapshotBeforeUpdate"><a href="#1-3-getDerivedStateFromProps和getSnapshotBeforeUpdate" class="headerlink" title="1.3 getDerivedStateFromProps和getSnapshotBeforeUpdate"></a>1.3 getDerivedStateFromProps和getSnapshotBeforeUpdate</h3><ul><li>getDerivedStateFromProps<br>getDerivedStateFromProps接受最新的props值和上一个state两个参数，返回一个对象来更新state，或者返回null表示不更新state。但是，<code>getDerivedStateFromProps不能访问this</code>，所以如果要和上一次的props做比较，只能把props值存到state里作为镜像。</li><li>getSnapshotBeforeUpdate<br>getSnapshotBeforeUpdate触发的时机是在最近的更改被提交到DOM前，使得组件可以在更改之前获取到当前值，此函数返回的值会作为componentDidUpdate的第三个参数传入</li></ul><h3 id="什么是PureComponent"><a href="#什么是PureComponent" class="headerlink" title="什么是PureComponent"></a>什么是PureComponent</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用AbortController中断请求</title>
      <link href="/posts/592624706/"/>
      <url>/posts/592624706/</url>
      
        <content type="html"><![CDATA[<h2 id="使用AbortController中断请求"><a href="#使用AbortController中断请求" class="headerlink" title="使用AbortController中断请求"></a>使用AbortController中断请求</h2><p><code>AbortController</code>是DOM规范的一部分，用来中止一个或多个DOM请求。DOM请求可以是Promise或者fetch等。</p><p><strong><em>用法</em></strong></p><p>  使用<code>new AbortController()</code>构造函数创建一个<code>AbortController</code>对象示例，<code>AbortController</code>对象上有个<code>signal</code>属性，可以用来<code>with/abort</code>一个Web请求。使用<code>AbortController.abort()</code>方法中断一个尚未完成Web请求。</p><p><strong><em>示例</em></strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">export default function App() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 创建AbortController对象</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  const controller &#x3D; new AbortController();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 获取signal属性</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  const signal &#x3D; controller.signal;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  const doSomethingAsync &#x3D; (&#123;signal&#125;) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    if (signal.aborted) return Promise.reject(new DOMException(&#39;Aborted&#39;, &#39;AbortError&#39;));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      console.log(&#39;Promise Started&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      const timeout &#x3D; window.setTimeout(resolve, 10000, &#39;Promise Resolved&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">      signal.addEventListener(&#39;abort&#39;, () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        window.clearTimeout(timeout);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        reject(new DOMException(&#39;Aborted&#39;, &#39;AbortError&#39;));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  const getData &#x3D; () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    doSomethingAsync(&#123; signal &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">      .then(result &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">          console.log(result);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">      &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      .catch(err &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        console.log(err);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">          if (err.name &#x3D;&#x3D;&#x3D; &#39;AbortError&#39;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">              console.log(&#39;Promise Aborted&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">          &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">              console.log(&#39;Promise Rejected&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">  const abortReuqest &#x3D; () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 调用abort方法中断请求</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    controller.abort();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">      &lt;button onClick&#x3D;&#123;getData&#125;&gt;开始请求&lt;&#x2F;button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">      &lt;button onClick&#x3D;&#123;abortReuqest&#125;&gt;中断请求&lt;&#x2F;button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    &lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面的DOMContentLoaded事件</title>
      <link href="/posts/503882416/"/>
      <url>/posts/503882416/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的事件循环</title>
      <link href="/posts/3084422494/"/>
      <url>/posts/3084422494/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript中的事件循环"><a href="#JavaScript中的事件循环" class="headerlink" title="JavaScript中的事件循环"></a>JavaScript中的事件循环</h2><h3 id="为什么会有事件循环"><a href="#为什么会有事件循环" class="headerlink" title="为什么会有事件循环"></a>为什么会有事件循环</h3><p>首先我们知道，<code>JavaScript是一门单线程的非阻塞的脚本语言</code></p><blockquote><ol><li><strong>单线程</strong>: JavaScripts是单线程的，指的是JavaScript引擎中解析和执行JavaScript的线程只有一个（主线程）， 每次只能做一件事情。单线程是必然的，因为如果JavaScript是多线程，那么当两个线程同时对一个dom进行操作，例如一个向其添加事件监听，而另一个删除了该dom，这个是矛盾的。</li><li><strong>非阻塞</strong>: 当我们的JavaScript代码运行一个异步任务的时候（像ajax等），主线程会挂起这个任务，然后异步任务返回结果的时候再根据特定的结果去执行相应的回调函数。</li></ol></blockquote><p>那么如何做到非阻塞呢？这就需要——<code>事件循环(Event Loop)</code></p><h3 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h3><p>下面这张图可以帮助您了解JavaScript的调用堆栈/事件循环/回调队列如何相互影响</p><p><img alt="Event Loop" data-src="/posts/3084422494/event_loop.png" class="lazyload"></p><p>当JavaScript代码执行的时候回将不同的变量存于内存中的不同位置：堆(heap)或者栈(stack)中来加以区分。其中，堆里存放的是一些对象，而栈中则存放的是一些基础类型变量以及对象的指针。</p><p><strong>执行栈</strong></p><p>当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方，这个地方就叫<code>执行栈</code>。</p><p>比如下面是一段同步执行的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function a() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    b();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;a&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">function b() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;b&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">a();</span></pre></td></tr></table></figure><p>下图演示的是代码的执行过程：<br><img alt="Sync " data-src="/posts/3084422494/sync.png" class="lazyload"></p><ol><li>执行函数a先入栈  </li><li>函数a中先执行函数b，b入栈</li><li>执行函数b，console.log(b)入栈</li><li>输出b，console.log(b)出栈</li><li>函数b执行完成，b出栈</li><li>console.log(‘a’)入栈，执行。输出a，出栈 </li><li>函数a执行完成，a出栈</li></ol><p>同步代码的执行过程比较简单，那异步的呢？</p><p>JavsScript引擎遇到一个异步事件后并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，JavaScript会将这个事件加入到与当前执行栈不同的另一个队列，称为<strong>事件队列</strong></p><p>被放入事件队列之后不会立即执行起回调，而是等待当前执行栈中的所有任务都执行完毕，主线程空闲状态，主线程会去查找事件队列中是否有任务，如果有，则取出排在第一位的事件，并把这个事件对应的回调放到执行栈中，然后执行其他的同步代码。</p><p>看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$.on(&#39;button&#39;, &#39;click&#39;, function onClick() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    setTimeout(function timer() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        console.log(&#39;You clicked the button!&#39;);    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;, 2000);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hi!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">setTimeout(function timeout() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    console.log(&quot;Click the button!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;, 5000);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">console.log(&quot;Welcome to loupe.&quot;);</span></pre></td></tr></table></figure><p>下图演示的是代码的执行过程：<br><img alt="Sync " data-src="/posts/3084422494/async.gif" class="lazyload"></p><p>来分析下执行过程：</p><ol><li>首先是，注册了点击事件，异步执行，这个时候会把它放到Web api中</li><li>console.log(“Hi!”)入栈，直接执行，输出Hi</li><li>执行setTimeout， 异步执行，先挂载起来</li><li>执行console.log(“Welcome to loupe.”)，输出Welcome to loupe.</li><li>5秒钟后，setTimeout执行回调，将回调放入事件队列中，一旦主线程空闲，则取出运行。</li><li>此时点击按钮，触发点击事件，将点击事件的回调放入到事件队列中，一旦主线程空闲，则取出运行</li><li>运行点击事件中的setTimeout</li><li>2秒后，setTimeout执行回调，将回调放入事件队列中，一旦主线程空闲，则取出运行。</li></ol><h2 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h2><h3 id="微任务——Micro-Task"><a href="#微任务——Micro-Task" class="headerlink" title="微任务——Micro-Task"></a>微任务——Micro-Task</h3><p>常见的有<code>process.nextTick</code>、<code>new Promise().then(callback)</code>、 <code>MutationObserver</code>,它们的优先级是<code>process.nextTick &gt; Promise = MutationObserver</code></p><h3 id="宏任务——Micro-Task"><a href="#宏任务——Micro-Task" class="headerlink" title="宏任务——Micro-Task"></a>宏任务——Micro-Task</h3><p>常见的有<code>setTimeout</code>、 <code>setInterval</code>、 <code>主代码块</code>、<code>I/O操作</code>、 <code>UI交互事件</code>、 <code>postMessage</code>等。优先级是<code>主代码块 &gt; setImmediate &gt; MessageChannel &gt; setTimeout / setInterval</code>，大部分浏览器会把DOM事件回调优先处理 因为要提升用户体验 给用户反馈，其次是network IO操作的回调，再然后是UIrender，之后的顺序就难以捉摸了，其实不同浏览器的表现也不太一样，这里不做过多讨论。</p><h3 id="事件循环的执行顺序"><a href="#事件循环的执行顺序" class="headerlink" title="事件循环的执行顺序"></a>事件循环的执行顺序</h3><p>异步任务的返回结果会被放到一个事件队列中，根据上面提到的异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。</p><p><code>Event Loop</code>的循环过程如下：</p><ol><li>执行一个宏任务(一般是主代码块),如果没有可选的宏任务，则直接处理微任务</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>执行过程中如果遇到宏任务，就将它添加到宏任务的任务队列中</li><li>执行一个宏任务完成之后，就需要检测微任务队列有没有需要执行的任务，有的话，全部执行，没有的话，进行下一步</li><li>检查渲染，然后<code>GUI</code>线程接管渲染，进行浏览器渲染</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（…循环上面的步骤）</li></ol><p>总结就是：<code>执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，等所有微任务执行完毕后，再回到宏任务中进行下一轮循环</code></p><p>看下面这个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">console.log(&#39;start&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;setTimeout&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;, 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(function() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;promise1&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;).then(function() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;promise2&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">console.log(&#39;end&#39;)</span></pre></td></tr></table></figure><p>分析一下流程：</p><ol><li>执行console.log(‘start’), 输出start</li><li>执行setTimeout，压入宏任务队列</li><li>执行promise.then，回调压入微任务队列</li><li>执行console.log(‘end’)，输出end</li><li>主流程属于宏任务，执行完成后接下来要执行微任务队列中的任务了，也就是执行promise.then,输出promise1</li><li>此时又promise的第二个回调函数，压入微任务队列。由于event loop会把当前的微任务队列一直执行完，所以继续执行promise的第二个回调函数，输出promise2</li><li>这时微任务队列已经为空，接下来主线程会进行一些UI渲染工作（非一定要做），然后开始下一轮event loop，执行宏任务队列的任务。</li><li>此时宏任务队列中仅剩下setTimeout的回调，输出setTimeout</li></ol><p>故最后的输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">start</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">end</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">promise then 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">promise then 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">setTimout</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrtipt标签的defer和async</title>
      <link href="/posts/1750268648/"/>
      <url>/posts/1750268648/</url>
      
        <content type="html"><![CDATA[<h2 id="Scrtipt标签的defer和async"><a href="#Scrtipt标签的defer和async" class="headerlink" title="Scrtipt标签的defer和async"></a>Scrtipt标签的defer和async</h2><p>defer和async是script标签的两个属性，用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。为什么设计这两个属性呢？</p><p><strong><em>为什么给要script标签添加 async 或 defer？</em></strong></p><p>首先需要了解一下页面的加载和渲染过程：</p><ol><li>浏览器通过http协议请求服务器，获取HTML文档并开始从上到下解析，构建DOM;</li><li>在构建DOM过程中，如果遇到外联的样式声明和脚本声明，则暂停文档解析，创建新的网络连接，并开始下载样式文件和脚本文件;</li><li>样式文件下载完成后，构建CSSDOM;脚本文件下载完成后，解析并执行，然后继续解析文档并构建DOM;</li><li>完成文档解析后，将DOM和CSSDOM进行关联和映射，最后将视图渲染到浏览器窗口。在这个过程中，脚本文件的下载和执行是与文档解析同步进行的，也就是说，<code>脚本的解析和执行会阻塞文档的解析</code>，如果控制不好，在用户体验上就会造成一定程度的影响。</li></ol><p>为了避免js和css会阻塞文档解析，比较流行的做法是<code>样式放顶部，脚本放底部</code>，但是这种做法并没有从根本上解决问题。实际上，并不是所有的脚本对用户体验都是同等的重要，能否有一种解决方法，可以尽可能的异步加载那些不那么重要的脚本。</p><p><strong><em>defer和async的作用</em></strong></p><p><code>defer</code>和<code>async</code>属性，就是用来告诉浏览器哪些脚本是需要异步加载的。这两个属性都告诉浏览器，在加载脚本的同时继续解析HTML，并在脚本加载完之后再执行。这样脚本下载就不会阻塞DOM构建和页面渲染了。结果就是，用户可以在所有的脚本加载完成之前就能看到页面了。</p><p><strong><em>defer和async的区别</em></strong> </p><p>两者的区别在于<code>执行时间不同</code>。</p><ol><li><p>默认引用script： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;x.min.js&quot;&gt;&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure><p>当浏览器遇到script标签时，<code>文档的解析将会停止，然后立即下载脚本并执行，脚本执行完毕后在解析文档</code>。</p></li><li><p>async模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;x.min.js&quot; async&#x3D;&quot;async&quot;&gt;&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure><p>当浏览器遇到script标签时，<code>文档解析不会停止而是会继续往下解析，同时异步下载脚本。脚本下载完成后会立即执行脚本，此时会中断文档的解析过程，直到脚本执行完毕</code>。</p></li><li><p>defer模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;x.min.js&quot; defer&#x3D;&quot;defer&quot;&gt;&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure><p>当浏览器遇到script标签时，<code>文档解析不会停止而是会继续往下解析，同时异步下载脚本。等到文档解析完毕后，脚本才会执行</code>。</p></li></ol><blockquote><p>所以async和defer的区别就是，async是脚本下载完毕后会立即执行，defer是等到文档解析完成后再执行脚本。</p></blockquote><p><strong><em>总结</em></strong></p><ul><li><p>相同 </p><ol><li>都是异步的加载脚本文件，加载时不会阻塞DOM渲染</li><li>都是在页面load之前执行</li><li>对于内嵌脚本无效。即缺少src属性。</li></ol></li><li><p>不同   </p><ol><li>async属性的脚本无法确定是在<code>DOMContentLoaded</code>之前还是之后执行。defer属性的脚本一定是在<code>DOMContentLoaded</code>之前执行</li><li>async属性的脚本并不一定按照顺序执行（先加载完成的先执行）。defer属性的脚本会按照顺序执行</li></ol></li></ul><p><strong><em>其他</em></strong></p><p>  <strong>css阻塞有什么解决办法？</strong></p><blockquote><p>css的加载不会导致HTML解析和渲染的阻塞，但会影响到js脚本的执行。因为js脚本不仅可以读取修改dom，也可以读取修改cssom。故在js脚本执行前，浏览器必须保证css文件完全加载完毕，即cssom树完全构建好。这就导致了js脚本执行的延迟，这是css的加载阻塞js脚本执行的根本原因。</p></blockquote><p>  对此，这里有一些解决办法：</p><ul><li>在引入顺序上，css资源的引入要由于js资源的引入。</li><li>对css进行精简并尽快提供</li><li>可以用媒体类型（会加载不会阻塞）</li><li>用媒体查询（会记载，只有在符合的设备上才会进行阻塞）</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React路由设置createBrowserHistory之后页面刷新报错问题解决</title>
      <link href="/posts/2425023234/"/>
      <url>/posts/2425023234/</url>
      
        <content type="html"><![CDATA[<h2 id="React路由设置createBrowserHistory之后页面刷新报错问题解决"><a href="#React路由设置createBrowserHistory之后页面刷新报错问题解决" class="headerlink" title="React路由设置createBrowserHistory之后页面刷新报错问题解决"></a>React路由设置createBrowserHistory之后页面刷新报错问题解决</h2><p><strong><em>问题</em></strong></p><p>使用browserHistory时页面刷新时控制台会报错：<code>Uncaught SyntaxError: Unexpected token &lt;</code></p><p><strong><em>解决办法</em></strong></p><p>在index.html中修改资源引入路径，使用绝对路径进行引入</p><p>例如：</p><p><img alt="修改前" data-src="/posts/2425023234/before.png" class="lazyload"></p><p>使用绝对路径引入:</p><p><img alt="修改后" data-src="/posts/2425023234/after.png" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写防抖、节流</title>
      <link href="/posts/2442577863/"/>
      <url>/posts/2442577863/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>npm 依赖包版本号~和^的区别</title>
      <link href="/posts/2795930560/"/>
      <url>/posts/2795930560/</url>
      
        <content type="html"><![CDATA[<h2 id="npm-依赖包版本号-和-的区别"><a href="#npm-依赖包版本号-和-的区别" class="headerlink" title="npm 依赖包版本号~和^的区别"></a>npm 依赖包版本号~和^的区别</h2><ul><li><code>~</code>会匹配最近的小版本依赖包，比如<code>~1.2.3</code>会匹配所有1.2.x版本，但是不包括1.3.0</li><li><code>^</code>会匹配最新的大版本依赖包，比如<code>^1.2.3</code>会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0</li><li><code>*</code>会安装最新版本的依赖包</li></ul><p>那么该如何选择呢？当然你可以指定特定的版本号，直接写1.2.3，前面什么前缀都没有，这样固然没问题，但是如果依赖包发布新版本修复了一些小bug，那么需要手动修改package.json文件；<code>~</code>和<code>^</code>则可以解决这个问题。<br>但是需要注意<code>^</code>版本更新可能比较大，会造成项目代码错误，所以建议使用<code>~</code>来标记版本号，这样可以保证项目不会出现大的问题，也能保证包中的小bug可以得到修复。<br>版本号写<code>*</code>，这意味着安装最新版本的依赖包，但缺点同上，可能会造成版本不兼容，慎用！</p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MessageChannel消息通道</title>
      <link href="/posts/2399429143/"/>
      <url>/posts/2399429143/</url>
      
        <content type="html"><![CDATA[<h2 id="MessageChannel消息通道"><a href="#MessageChannel消息通道" class="headerlink" title="MessageChannel消息通道"></a>MessageChannel消息通道</h2><p>在浏览器环境中，常见的宏任务有 <code>setTimeout/setInterval</code>、<code>MessageChannel</code>、<code>postMessage</code> 和 <code>setImmediate</code>等。常见的微任务有 <code>Promise.then</code> 和 <code>MutationObserver</code>等。Vue中对于宏任务的实现，会优先监测是否支持原生<code>setImmediate</code>，这是一个高版本IE和Edge才支持的特性，不支持的话再去检测是否支持原生的<code>MessageChannel</code>，如果也不支持的话会降级为setTimeout 0。</p><h3 id="MessageChannel"><a href="#MessageChannel" class="headerlink" title="MessageChannel"></a>MessageChannel</h3><p><code>MessageChannel</code>允许我们创建一个新的消息通道，并通过它的两个<code>MessagePort</code>属性发送数据。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个管道</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">var channel &#x3D; new MessageChannel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取实例的两个端口</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">var port1 &#x3D; channel.port1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">var port2 &#x3D; channel.port2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 给每个端口绑定onmessage事件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">port1.onmessage &#x3D; function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    console.log(&quot;port1收到来自port2的数据：&quot; + event.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">port2.onmessage &#x3D; function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    console.log(&quot;port2收到来自port1的数据：&quot; + event.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个端口只要绑定了onmessage事件，就可以接受从另一个端口发出的消息</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">port1.postMessage(&quot;发送给port2&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">port2.postMessage(&quot;发送给port1&quot;);</span></pre></td></tr></table></figure><p>简单来说，<code>MessageChannel</code>创建了一个通信的管道，管道有两个端口，每个端口都是只读的。这两个端口都可以通过postMessage发送消息。当一个端口绑定了onmessage事件时，就可以接受从另一个端口发出的消息。</p><p>消息通道就像是一条左右贯通的管道，左右两个端口就是 port1 和 port2</p><p>这两个端口可以相互发送消息，port1 发送的消息可以在 port2 接收到，反之亦然</p><p><img alt="MessageChannel" data-src="/posts/2399429143/MessageChannel.png" class="lazyload"></p><h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><p><strong>深拷贝</strong></p><p>大部分需要深拷贝的场景，都可以使用以下代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">JSON.parse(JSON.stringify(object))</span></pre></td></tr></table></figure><p>但这种办法会忽略掉<code>undefined</code>、<code>null</code>、<code>symbol</code>和<code>循环引用的对象</code>，而通过<code>postMessage</code>方法传输的<code>message</code>是深拷贝的，可以拷贝undefined和循环引用的对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function deepClone(msg) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  var ms &#x3D; new MessageChannel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; onmessage是异步的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    ms.port1.onmessage &#x3D; function(e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      resolve(e.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    ms.port2.postMessage(msg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  var obj &#x3D; &#123;name: &#39;zs&#39;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  var obj1 &#x3D; await deepClone(obj);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  obj.age &#x3D; 18;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  console.log(obj); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  console.log(obj1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">test();</span></pre></td></tr></table></figure><p>但<code>MessageChannel</code>对于<code>Symbol</code>和<code>function</code>依然束手无策</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Worker介绍</title>
      <link href="/posts/3671681857/"/>
      <url>/posts/3671681857/</url>
      
        <content type="html"><![CDATA[<h2 id="Web-Worker介绍"><a href="#Web-Worker介绍" class="headerlink" title="Web Worker介绍"></a>Web Worker介绍</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JavaScript采用的是单线程非阻塞模型，所有任务只能在一个线程上跑，一次只能做一件事。前面的任务没做完，后面的任务只能等着，随着多核CPU的出现，单线程带来的不便，无法充分发挥计算机的计算能力。</p><p><code>Web Worker</code>的出现，就是为JavaScript创造了多线程环境，允许主线程创建Worker线程，将一些任务分配给后者运行。在主线程运行的时候，Worker线程在后台运行，两者互不干扰，等到Worker线程计算完成，再把结果返回给主线程，这样的好处是，一些计算密集型或者高延迟的任务可以交给Worker线程来承担，主线程会很流畅，不会被阻塞或者拖慢。</p><p>但是Worker线程一旦新建成功，就会始终运行，不会被主线程的活动（比如用户点击按钮，提交表单）打断。这样有利于随时响应主线程的通信，但是这样也造成了Worker比较耗费资源，不应该过度使用,而且一旦使用完毕，应当立即关闭。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>Web Worker有以下几个使用注意点：</p><ul><li><p>同源限制</p><p>分配给Worker线程运行的脚本文件，必须与主线程的脚本文件同源</p></li><li><p>DOM限制</p><p>Worker线程所在的全局对象，与主线程不一样，无法读取主线程所在页面的DOM对象，也无法使用document, window, parent这些对象。但是Worker线程可以使用 navigator 和 location 对象</p></li><li><p>通信联系</p><p>Worker线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p></li><li><p>脚本限制</p><p>Worker线程不能使用alert和confirm方法，但可以使用XMLHttpRequest对象发出ajax请求</p></li><li><p>文件限制</p><p>Worker线程无法读取本地文件，即不能打开本机的文件系统（file://)，它所加载的脚本必须来自网络。</p></li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li><p>主线程</p><p>主线程采用new命令，调用Worker()构造函数，新建一个Worker线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var worker &#x3D; new Worker(&#39;work.js&#39;);</span></pre></td></tr></table></figure><p>Worker()构造函数接受一个脚本文件作为参数，该文件就是Worker线程所要执行的任务，如果读取脚本文件失败，Worker会默默的失败。</p><p>然后主线程调用Worker.postMessage()方法，向Worker发消息，方法的参数就是发送的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">worker.postMessage(&#39;hello world&#39;);</span></pre></td></tr></table></figure><p>接着主线程通过worker.onmessage指定监听函数，接受子线程发来的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">worker.onmessage &#x3D; function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;接收到子线程发来的消息：&#39; + event.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><p>Worker完成任务以后，主线程就可以把它关掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">worker.terminate();</span></pre></td></tr></table></figure></li><li><p>worker线程<br>worker线程内部需要一个监听函数，监听message事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">self.addEventListener(&#39;message&#39;, function(e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  self.postMessage(e.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>上面代码中，self代表子线程自身，即子线程的全局对象，等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">this.addEventListener(&#39;message&#39;, function(e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  self.postMessage(e.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 或</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">addEventListener(&#39;message&#39;, function(e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  self.postMessage(e.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>另外，</p><ol><li>worker使用完毕，为了节省系统资源，必须关闭。主线程使用<code>worker.terminate()</code>关闭worker线程, <code>self.close()</code>用于在Worker内部关闭自身。</li><li>Worker内部如果想加载其他脚本，有一个专门的方法<code>importScripts()</code>, 该方法可以同时加载多个脚本。: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">importScripts(&#39;script1.js&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;);</span></pre></td></tr></table></figure></li><li>主线程可以监听Worker是否发生错误，如果发生错误，Worker会触发主线程的error事件。worker内部也可以监听error事件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">worker.onerror(function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 或者</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">worker.addEventListener(&#39;error&#39;, function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><h3 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h3></li></ol><p>主线程于worker线程之间的通信内容，可以是文本，也可以是对象。需要注意的是，<code>这种通信是拷贝，是传值而不是传址</code>，worker对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行后的字符串传给worker，后者再将其还原。</p><p>但是这种拷贝的方式发送二进制数据会造成性能问题，比如主线程向worker发生一个500MB文件，默认情况下浏览器会生成一个原文件的拷贝，为了解决这个问题，JavaScript允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫<code>transferable objects</code>，这使得主线程可以快速把数据交给Worker，对应影像处理、声音处理、3D运算等就非常方便，不会产生性能负担。 </p><p>如果要直接转移数据的控制权，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; transferable objects 格式</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">worker.postMessage(arrayBuffer, [arrayBuffer]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 例子</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">var ab &#x3D; new ArrayBuffer(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">worker.postMessage(ab, [ab])</span></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setImmediate函数</title>
      <link href="/posts/3084422494/"/>
      <url>/posts/3084422494/</url>
      
        <content type="html"><![CDATA[<h2 id="setImmediate函数"><a href="#setImmediate函数" class="headerlink" title="setImmediate函数"></a>setImmediate函数</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>setImmediate函数用来把一些需要长时间运行的操作放到一个回调函数中，并在浏览器完成其他操作后立即执行。使用此方法可以替代setTimeout(fn, 0)方法。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var immediateID &#x3D; setImmediate（func，[ param1，param2，...]）;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">var immediateID &#x3D; setImmediate（func）;</span></pre></td></tr></table></figure><ul><li>immediateID 是这次setImmediate方法设置的唯一ID,可以作为 window.clearImmediate 的参数.</li><li>func 是将要执行的回调函数，参数param1 param2 ..都会直接传给函数func</li><li>window.clearImmediate 方法可以用来取消通过setImmediate设置的将要执行的语句, 就像 window.clearTimeout 对应于 window.setTimeout一样.</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>此函数是非标准的，能存在很大的不兼容性，目前仅IE和Node.js 0.10+的最新版本实现。Firefox和谷歌不支持此函数！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的 MutationEvents 和 MutationObserver</title>
      <link href="/posts/3084422494/"/>
      <url>/posts/3084422494/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript中的-MutationEvents-和-MutationObserver"><a href="#JavaScript中的-MutationEvents-和-MutationObserver" class="headerlink" title="JavaScript中的 MutationEvents 和 MutationObserver"></a>JavaScript中的 MutationEvents 和 MutationObserver</h2><h3 id="MutationEvents"><a href="#MutationEvents" class="headerlink" title="MutationEvents"></a>MutationEvents</h3><p>MutationEvents是一系列dom树的变动的监听事件，总共有9种事件： </p><ul><li>DOMAttrModified</li><li>DOMAttributeNameChanged</li><li>DOMCharacterDataModified</li><li>DOMElementNameChanged</li><li>DOMNodeInserted</li><li>DOMNodeInsertedIntoDocument</li><li>DOMNodeRemoved</li><li>DOMNodeRemovedFromDocument</li><li>DOMSubtreeModified</li></ul><p><strong>用法</strong></p><p>以下是给document注册DOMNodeInserted事件的示例，当dom树结构发生变动时触发回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;DOMNodeInserted&quot;, function () &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; do something</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p><strong>注意</strong><br>MutationEvents 的所有事件都被设计成<code>不可取消</code>，意味着一旦注册之后不能再removeEventListener取消监听了。MutationEvents 事件机制是同步的，也就是说每次DOM修改就会触发，修改几次就触发几次，影响性能。</p><h3 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h3><p>MutationObserver, dom树的变动观察者，是用来<code>监听DOM树的更改</code>，它是作为旧的MutationEvents的替代品，它的出现就是为了解决MutationEvents的问题。</p><p>MutationObserver 是个构造器，接受一个函数作为参数，这个函数会在节点变化时回调，同时返回两个参数，mutations： 节点变化记录列表， observer： MutationObserver对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var observer &#x3D; new MutationObserver(function (mutations, observer) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>MutationObserver有三个方法：</p><ul><li>observe: 设置观察目标<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mutationObserver.observe(target[, options])</span></pre></td></tr></table></figure></li><li>disconnect: 阻止观察者观察任何改变</li><li>takeRecords: 清空记录队列并返回里面的内容</li></ul><p><strong>用法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 选择需要观察变动的节点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">const targetNode &#x3D; document.getElementById(&#39;some-id&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 观察器的配置（需要观察什么变动）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const config &#x3D; &#123; attributes: true, childList: true, subtree: true &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当观察到变动时执行的回调函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">const callback &#x3D; function(mutationsList, observer) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; Use traditional &#39;for loops&#39; for IE 11</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    for(let mutation of mutationsList) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        if (mutation.type &#x3D;&#x3D;&#x3D; &#39;childList&#39;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            console.log(&#39;A child node has been added or removed.&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        else if (mutation.type &#x3D;&#x3D;&#x3D; &#39;attributes&#39;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            console.log(&#39;The &#39; + mutation.attributeName + &#39; attribute was modified.&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个观察器实例并传入回调函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">const observer &#x3D; new MutationObserver(callback);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 以上述配置开始观察目标节点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">observer.observe(targetNode, config);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 之后，可停止观察</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">observer.disconnect();</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object.freeze函数</title>
      <link href="/posts/3106097719/"/>
      <url>/posts/3106097719/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-freeze函数"><a href="#Object-freeze函数" class="headerlink" title="Object.freeze函数"></a>Object.freeze函数</h2><p>Object.freeze(),冻结函数，该方法用于冻结一个对象。<code>一个被冻结的对象将不能修改属性，删除已有属性或添加新的属性</code>。此外，<code>冻结一个对象之后，该对象的原型也不能被修改</code>。该方法的返回值为传入的对象。</p><p>看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; age: 18 &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Object.freeze(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">a.age &#x3D; 20;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">a.name &#x3D; &#39;zs&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">delete a.age; &#x2F;&#x2F; false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr></table></figure><p>同时冻结的对象的原型也不能被修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; age: 18 &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Object.freeze(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">var b &#x3D; a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">b.age &#x3D; 20;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">console.log(b); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr></table></figure><p>但是，Object.freeze()只是<code>浅冻结</code>，被冻结的对象并不总是不可变的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; name: &#123; firstName: &#39;zhang&#39; &#125; &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Object.freeze(a);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">a.name.firstName &#x3D; &#39;wang&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123; name: &#123; firstName: &quot;wang&quot; &#125; &#125;</span></pre></td></tr></table></figure><p>最后，需要注意的是，<code>只要freeze之后，就不能解除了</code>，所以使用这个API需要谨慎</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack之tree shaking</title>
      <link href="/posts/42071/"/>
      <url>/posts/42071/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack之tree-shaking"><a href="#webpack之tree-shaking" class="headerlink" title="webpack之tree shaking"></a>webpack之tree shaking</h2><p>webpack从2.0开始引入tree shaking概念。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>先了解下webpack中几个相关概念：</p><ul><li><p>AST<br>AST对JS代码进行语法分析后得出的语法树（Abstract Syntax Tree）。AST语法树可以把一段JS代码的每一个语句转化成语法树中的一个节点。</p></li><li><p>DCE<br>Dead Code Elimination,在保持代码运行结果不变的前提下，去除无用的代码。这样的好处是：</p><ul><li>优化代码</li><li>减小程序体积</li><li>减少程序执行时间</li></ul><p>其中Dead Code指的是：</p><ul><li>程序中不会执行的代码（如不可能进入的分支，return之后的代码等）</li><li>写入变量之后不再读取的代码</li></ul></li></ul><p>tree shaking是 DCE 的一种方式，它可以在打包时忽略没有用到代码。</p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>首先需要知道webpack的运行机制：</p><ol><li><p>先使用babel-loader处理js文件</p><p> babel的配置文件中有一个preset配置项：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  preset: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    [&#39;env&#39;, &#123; &#39;module&#39;: false &#125;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p> 其中presets里的env有个module的配置项，设置为false，这是指示babel如何去处理impory和export等关键字，默认以require形式，设置为false则babel就不会把import，export转成require形式了，这也为webpack的tree shaking创造了条件。</p></li><li><p>然后webpack进行tree-shaking识别和记录，打包处理</p><p> <code>webpack在认定某块代码无用后，会再处理过程中写下一段注释。uplifyjs会根据这点注释去进行删除代码。</code></p><p> webpack负责对代码进行标记，把import&amp;export分为3类：</p><ul><li>所有import标记为 /* harmony import */ </li><li>被使用过的export标记为 /* harmony export([type]) */, 其中type和webpack有关，可能是binding，immutable等</li><li>没被使用过的import标记为 /* unused harmony export [FunctionName] */, 其中FunctionName即export的方法名称</li></ul></li><li><p>最后由uglifyjs根据webpack标识删除多余代码，进行代码压缩</p></li></ol><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React.memo和useMemo的使用</title>
      <link href="/posts/56913/"/>
      <url>/posts/56913/</url>
      
        <content type="html"><![CDATA[<h2 id="React-memo和useMemo的使用"><a href="#React-memo和useMemo的使用" class="headerlink" title="React.memo和useMemo的使用"></a>React.memo和useMemo的使用</h2><p>在React的class Component时代，为了性能优化我们经常使用<code>pureComponent + shouldComponentUpdate</code>对组件进行深层次的控制。</p><p>到了Funciton Component时代，React也提供了<code>memo</code>和<code>useMemo</code>，以达到<code>pureComponent + shouldComponentUpdate</code>同样效果。</p><h3 id="先看个例子："><a href="#先看个例子：" class="headerlink" title="先看个例子："></a>先看个例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, memo, useMemo &#125; from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">import &#123; Input &#125; from &#39;antd&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">export default class TestMemo extends Component &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  state &#x3D; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    firstName: &#39;x&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    lastName: &#39;f&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  handleChange(key, value) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    this.setState(&#123; [key]: value &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;render&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    const &#123; firstName, lastName &#125; &#x3D; this.state;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &lt;Input label&#x3D;&#39;姓&#39; value&#x3D;&#123;firstName&#125; onChange&#x3D;&#123;e &#x3D;&gt; this.handleChange(&#39;firstName&#39;, e.target.value)&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &lt;Input label&#x3D;&#39;名&#39; value&#x3D;&#123;lastName&#125; onChange&#x3D;&#123;e &#x3D;&gt; this.handleChange(&#39;lastName&#39;, e.target.value)&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &lt;FristName name&#x3D;&#123;firstName&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &lt;LastName name&#x3D;&#123;lastName&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      &lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">function FristName(&#123;name&#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render firstName&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">function LastName(&#123;name&#125;) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render lastName&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>仔细分析上面的例子，不难发现，每次在父组件的两个Input输入框任意一个中输入值，两个子组件<code>FristName</code>和<code>LastName</code>都会跟着渲染，即使跟子组件并不相关的props更新了，也渲染了一遍。<code>理论上，父组件每次变化一个 state 都通过 props 传递给了子组件，那子组件就会重新执行渲染。（无论子组件有没有真正用到这个 props）</code>，这无疑是浪费的渲染。</p><h3 id="使用memo"><a href="#使用memo" class="headerlink" title="使用memo"></a>使用memo</h3><p>下面我们使用memo对<code>FirstName</code>组件进行改造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import &#123; memo &#125; from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">const propsAreEqual &#x3D; function(prevProps, nextProps) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return prevProps.name &#x3D;&#x3D;&#x3D; nextProps;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const FristName &#x3D; memo((&#123;name&#125;) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render firstName&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;, propsAreEqual);</span></pre></td></tr></table></figure><p>使用了memo改造之后，我们会发现，当改变firstName后，<code>FirstName</code>组件会跟着渲染，而当改变lastName后，在控制台里可以看到<code>render firstName</code>并没有打印，说明<code>FirstName</code>组件并没有渲染，达到了性能优化的目的。</p><h3 id="使用useMemo"><a href="#使用useMemo" class="headerlink" title="使用useMemo"></a>使用useMemo</h3><p>看上面说那个memo的例子，我们发现React.memo是需要包裹整个组件的，并且需要手动写一个方法比较那些具体的props不相同才进行re-render。</p><p>而在某些场景下，我们只是希望component的某些部分不要进行re-render，而不是整个component编剧要re-render，也就是需要局部pure的功能。</p><p><code>useMemo</code>是React自带的hooks API，基本用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import &#123; useMemo &#125; from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">const memoizedValue &#x3D; useMemo(memoizedFunction(), [memoizedParams]);</span></pre></td></tr></table></figure><p>useMemo()返回的是一个memoized值，只有当依赖项memoizedParams发生改变，才会重新调用memoizedFunction函数计算生成新的memoizedValue。memoizedParams不变时不会触发memoizedFunction函数。</p><p>需要注意的是：<code>useMemo是在render期间执行的，所以不能进行一些副作用操作，比如网络请求等。</code></p><p>如果没有提供依赖项即memoizedParams，则每次都会调用memoizedFunction函数计算memoizedValue。</p><p>回到我们的例子，我们希望只有当lastName发生改变时，才会去重新渲染LastName组件，即用useMemo包裹return部分渲染的逻辑，下面是使用useMemo改造后的LastName组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function FristName(&#123;name&#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render firstName out useMemo&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return useMemo(() &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;render firstName in useMemo&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;, [name]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>再次运行时，我们会发现，<code>render firstName out useMemo</code>一直会打印，当我们没有改变firstName时，在useMemo函数中的这句<code>render firstName in useMemo</code>并不会打印，只有改变了firstName的值时，才会打印。这就是useMemo<code>局部pure</code>的体现了。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Hooks之useCallback</title>
      <link href="/posts/6797/"/>
      <url>/posts/6797/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Hooks之useCallback"><a href="#React-Hooks之useCallback" class="headerlink" title="React Hooks之useCallback"></a>React Hooks之useCallback</h2><p>useCallback</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>img标签的alt和title</title>
      <link href="/posts/8189/"/>
      <url>/posts/8189/</url>
      
        <content type="html"><![CDATA[<h2 id="img标签的alt和title属性"><a href="#img标签的alt和title属性" class="headerlink" title="img标签的alt和title属性"></a>img标签的alt和title属性</h2><p>在html的img标签中，有alt和title两个重要的属性。</p><h3 id="alt属性："><a href="#alt属性：" class="headerlink" title="alt属性："></a>alt属性：</h3><ul><li><p>如果图像没有下载或者加载失败，会用文字来代替图像显示。</p><p>  这一作用是为了给加载不出网页图片的用户提供图片信息，方便用户浏览网页，也方便维护网页。</p></li><li><p>搜索引擎可以通过这个属性的文字来抓取图片</p></li></ul><h3 id="title属性："><a href="#title属性：" class="headerlink" title="title属性："></a>title属性：</h3><ul><li>当网页上的图片被加载完成后，鼠标移动到上面去，会显示这个图片指定的属性文字，以对图片信息进行补充性说明。</li></ul>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to Panda-Wind&#39;s Blog</title>
      <link href="/posts/20593/"/>
      <url>/posts/20593/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://panda-wind.github.io/">Panda-Wind</a>! I will share some interesting things with you here.</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github Page 搭建个人博客（二）发布文章和url处理</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<p>前面我们已经搭建好了我们的博客网站，现在我们来发布新的文章吧！</p><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>新建文章，输入以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo new &#39;文章标题&#39;</span></pre></td></tr></table></figure><p>执行完成后，可以在根目录下/source</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github Page 搭建个人博客（一）安装</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建个人博客的方式有很多种，大多数都需要从各种网上代理商上买域名和服务器部署自己的博客系统。本文介绍的是使用 <code>Hexo</code> + <code>Github Page</code>来搭建，这是一种搭建速度最快，完全免费开源，不需要购买任何服务器资源即可运行的方式，而且有 many many 种博客主题供你选择。下面先简单介绍下<code>Hexo</code> 和 <code>Github Page</code>：</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Hexo</code> 是基于Node.js驱动的一款静态博客框架，除了官方提供的很多种主题，github上也有很多开发者分享的开源的主题，都可供使用者自由选择，而且切换主题也相当简单方便。<code>Github Page</code> 是 Github 提供的 一种静态网页托管服务，可以用来托管博客等静态网页资源，关键是免费的！结合使用<code>Hexo</code> + <code>Github Page</code> 可以帮助我们快速搭建个人博客。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>， <code>Hexo</code> 是基于Node.js的，所以需要准备Node环境。</li><li>创建<a href="https://github.com/" target="_blank" rel="noopener">github</a> 账号</li><li>安装<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>，将本地项目打包后生成的静态资源文件上传到github上进行托管。</li></ol><h2 id="Github上创建个人仓库"><a href="#Github上创建个人仓库" class="headerlink" title="Github上创建个人仓库"></a>Github上创建个人仓库</h2><p>首先创建个人仓库，用来存放博客所需要的文件资源：</p><p><img alt="github仓库名" data-src="/posts/undefined/hexo_1.jpg" class="lazyload"></p><p>这时候我们的博客站点<code>http://用户名.github.io</code>就建好了！当然由于是个空项目，访问是空白的。下面我们将使用hexo来创建一个项目来部署我们的站点。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ol><li>我们需要先安装<code>hexo-cli</code>脚手架，脚手架可以帮助我们创建一个完整可用的项目。在本地打开一个cmd窗口运行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span></pre></td></tr></table></figure></li><li>然后使用hexo新建一个项目：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo init 新建项目文件名</span></pre></td></tr></table></figure></li><li>安装npm包依赖:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install</span></pre></td></tr></table></figure>这时候我们打开刚刚新建的项目文件夹，看下目录结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">项目根目录</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">├── node_modules</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">├── scaffolds # 模版文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">|   ├── _drafts # 草稿文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">|   └── _posts # 文章Markdowm文件 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">└── themes  # 主题文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">├── package.json</span></pre></td></tr></table></figure>这时我们运行<code>hexo s</code>命令启动工程，其中 s 是 server 的缩写：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo s</span></pre></td></tr></table></figure>启动成功后，在浏览器中输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 回车就可以预览效果了！<br><img alt="预览效果" data-src="/posts/undefined/hexo_2.jpg" class="lazyload"></li></ol><p>可能到此处你会觉得奇怪，我们什么都没做，怎么就生成这么好看的一套页面出来了！那这就要归功于<code>hexo-theme</code>了。每一种<code>hexo-theme</code>都内置了大量的样式文件，我们只需简单的配置就能打造出非常酷炫好看的博客网站！hexo中提供了非常多种theme，除此之外，github上也有大量开源的theme供我们自主选择，免费使用！</p><h2 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h2><p>本地hexo博客系统开发完毕后，我们还需要部署到我们前面在github上创建的个人仓库里才能通过站点访问到。 </p><p>在部署之前，第一步，先安装一个插件<code>hexo-deployer-git</code>，用于本地hexo项目连接到远程git仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span></pre></td></tr></table></figure><p>第二步，打开项目根目录下的_config.yml配置文件配置远程github仓库的参数。直接拉到_config.yml文件末尾，找到deploy选项，按如下配置：<br><img alt="github配置" data-src="/posts/undefined/hexo_3.jpg" class="lazyload"></p><p>最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo g -d</span></pre></td></tr></table></figure><p>稍等一会，在浏览器访问网址： <code>https://用户名.github.io</code> 就会看到你的博客啦！！</p><h2 id="搞定"><a href="#搞定" class="headerlink" title="搞定"></a>搞定</h2><p>至此，我们的个人博客网站就创建好了！后续还会对博客网站加入改进，努力打造出一个炫酷精致的博客网站！</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
