<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pnpm是如何对npm和yarn进行降维打击的</title>
      <link href="/posts/2129100086/"/>
      <url>/posts/2129100086/</url>
      
        <content type="html"><![CDATA[<h2 id="pnpm-是如何对-npm-和-yarn-进行降维打击的"><a href="#pnpm-是如何对-npm-和-yarn-进行降维打击的" class="headerlink" title="pnpm 是如何对 npm 和 yarn 进行降维打击的"></a>pnpm 是如何对 npm 和 yarn 进行降维打击的</h2><p>经常听到 pnpm 比 npm 和 yarn 强大很多，但不知道具体好在哪里，今天一起看下。</p><p>按照前端包管理工具的发展历史，先从 npm2 开始讲起：</p><h3 id="npm2"><a href="#npm2" class="headerlink" title="npm2"></a>npm2</h3><hr><p>找个目录，执行下<code>npm init -y</code>，快速创建一个 package.json。</p><p>然后值<code>npm install express</code>，那么 express 包和它的依赖都会下载下来：</p><p><img alt="npm2-1.png" data-src="/posts/2129100086/npm2-1.png" class="lazyload"></p><p>展开 express，它也有 node_modules：</p><p><img alt="npm2-2.png" data-src="/posts/2129100086/npm2-2.png" class="lazyload"></p><p>再展开几层，每个依赖都有自己的 node_modules：</p><p><img alt="npm2-3.png" data-src="/posts/2129100086/npm2-3.png" class="lazyload"></p><p>也就是说 npm2 的 node_modules 是嵌套的。显而易见这样有个很大的问题就是，多个包之间难免有公共的依赖，这样嵌套的话会导致同样的依赖被复制很多次，会占据比较大的磁盘空间。还有个更致命的问题是 windows 系统的文件路径最长是 260 多个字符，这样嵌套的话可能会超过限制。</p><p>于是 yarn 就诞生了。</p><h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><hr><p>yarn 是如何解决依赖重复很多次，嵌套路径过长的问题呢？</p><p>答案是铺平。(npm 后来升级到 3 之后也是采用铺平的方案。)</p><p>所有的依赖不再一层层嵌套了，而是全部铺平在同一层，这样就解决了依赖重复多次的问题了，自然就解决了路径过长的问题。</p><p>但是有时候我们会发现还有会有嵌套的情况出现，为什么呢？</p><p>因为一个包可能有多个版本的，提升只能提升一个，所以后面在遇到相同包的不同版本，依然还是用嵌套的方式。</p><p>于是 yarn 还实现了 yarn.lock 来锁定版本的功能。(后来 npm 也实现了)</p><p>这种方案就没有问题了吗？</p><p>并不是，这种方案产生一个新的问题，那就是<code>幽灵依赖</code>，也就是你明明没有在 dependencies 里的依赖，但在代码里却可以 require 进来。</p><p>这个很容易理解，因为都平铺了嘛，那依赖的依赖自然也是能找到的。</p><p>但是这样有个隐患，因为这种幽灵依赖并没有显示的依赖，万一哪天别的包不依赖这个包了，那你的代码就不能跑了，因为你依赖的这个包现在不会安装了。同时还有一个问题，就是上面提到的依赖包有多个版本的问题，只会提升一个版本，那其他版本的包还是会复制很多次，依然有浪费磁盘空间的问题。</p><p>最后，pnpm 登场了。</p><h3 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h3><hr><p>回想下 npm 和 yarn 为什么要做扁平化？不就是因为相同的依赖被复制很多次吗？那如果不复制呢，那是通过 link。</p><blockquote><p>简单介绍下 link, 也就是软硬链接，这是操作系统提供的机制，硬链接就是同一个文件的不同引用，而软链接是新建一个文件，文件内容指向另一个路径。这两种使用起来是差不多的。</p></blockquote><p>所以如果不复制文件，只在全局保存一份包的内容，其余的地方都通过 link 链接过去呢？</p><p>当我们使用 pnpm 按照依赖时，会看到控制台打印这样一句话：</p><p><img alt="pnpm-1.png" data-src="/posts/2129100086/pnpm-1.png" class="lazyload"></p><p>包是从全局 store 硬链接到虚拟 store 的，这里的虚拟 store 就是 node_modules/.pnpm：</p><p><img alt="pnpm-2.png" data-src="/posts/2129100086/pnpm-2.png" class="lazyload"></p><p>我们会发现不是扁平化了，只有 express，没<br>有幽灵依赖。</p><p>展开.pnpm 看下：</p><p><img alt="pnpm-3.png" data-src="/posts/2129100086/pnpm-3.png" class="lazyload"></p><p>所有依赖都在这里铺平了，都是从全局 store 硬链接过来的，然后包和包之间的依赖关系是通过软链接组织的。</p><p>比如 .pnpm 下的 expresss，这些都是软链接:</p><p><img alt="pnpm-4.png" data-src="/posts/2129100086/pnpm-4.png" class="lazyload"></p><p>也就是说，所以的依赖都从全局 store 硬链接到 node_modules/.pnpm 下，然后之间再通过软链接相互依赖。</p><p>最后回过头看一下，为什么 pnpm 如此优秀呢？</p><ol><li>首先是节省磁盘空间，一个包全局只有一份，剩下的都是 link 链接</li><li>其次是快，因为不再是复制的方式而是链接</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><ol><li>npm2 是通过嵌套的方式关联 node_modules 的，这样会有依赖重复多次的问题。</li><li>yarn 和 npm3+ 是通过铺平的方式关联依赖的，同时使用了 yarn.lock 的方式管理，但无法解决多版本包还是会嵌套依赖的情况，同时会引出了幽灵依赖的隐患。</li><li>pnpm 是通过软硬链接的方式，不再是复制了，都是从全局的 store 硬链接到 node_modules/.pnpm，然后在通过软链接来组织依赖关系，这样大大节省了磁盘空间，并且速度更块，完胜 yarn 和 npm，pnpm 就是凭借这个对 npm 和 yarn 降维打击的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sendBeacon-实现数据上报</title>
      <link href="/posts/1232999462/"/>
      <url>/posts/1232999462/</url>
      
        <content type="html"><![CDATA[<h2 id="sendBeacon-应用场景"><a href="#sendBeacon-应用场景" class="headerlink" title="sendBeacon 应用场景"></a>sendBeacon 应用场景</h2><p>Navigator.sendBeacon() 是一个用于异步发送小型数据包的方法，它允许避免延迟敏感数据的丢失。</p><p>此方法旨在用户跳转或关闭一个页面后发送数据。在这种情况下，浏览器可能即将卸载页面而选择不发生异步的<code>XMLHttpRequest</code>请求。</p><h2 id="以往数据上报的方式"><a href="#以往数据上报的方式" class="headerlink" title="以往数据上报的方式"></a>以往数据上报的方式</h2><p>在 sendBeacon 出现之前，想要在页面离开前把数据发送出去，一般是延长页面的卸载时间，来及时发送数据。一般是在 <code>unload/beforeunload/pagehide</code> 方法里执行以下几种策略：</p><ol><li>通过使用阻塞的同步的 ajax 方法来发送数据;</li><li>创建一个 img 元素 + setTimeout 延迟来发送时刻;</li><li>创建一个无操作的一段时间循环;</li></ol><p>以上方法确实能延迟页面的卸载，但缺点是：一是会导致下一页的跳转变慢，给用户带来不好的体验；二是不稳定，如果请求返回比较慢，可能一样会被浏览器取消请求。</p><h2 id="使用-sendBeacon-实现数据上报"><a href="#使用-sendBeacon-实现数据上报" class="headerlink" title="使用 sendBeacon 实现数据上报"></a>使用 sendBeacon 实现数据上报</h2><p>如果使用 sendBeacon() 方法，虽然它也是异步发出请求，但是它的请求与当前页面线程脱钩，作为浏览器进程的任务，因此可以保证会把数据发出去，不拖延卸载流程。</p><h2 id="sendBeacon-特点"><a href="#sendBeacon-特点" class="headerlink" title="sendBeacon 特点"></a>sendBeacon 特点</h2><ol><li><p>只支持 post 方法</p></li><li><p>data 只支持 <code>ArrayBuffer</code>、<code>ArrayBufferView</code>、<code>Blob</code>、<code>DOMString</code>、<code>FormData</code>、<code>URLSearchParams</code> 这几种类型</p></li></ol><p>如果想支持 json 格式的内容怎么办？</p><p>可以使用 Blob 类型来实现。把 Blob 内容的格式类型设置为 json 格式就可以，看如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">const headers &#x3D; &#123; type: &#39;application&#x2F;json&#39; &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">const blob &#x3D; new Blob([JSON.stringify(&#123;a:1&#125;)], headers);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">window.navigator.sendBeacon(url, blob);</span></pre></td></tr></table></figure><ol start="3"><li>支持跨域</li></ol><p>如果请求的 content-type 类型是<code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>text/plain</code>，它不需要一个 option 预检来检查 cros，所以可以跨域。</p><p>如果请求的 content-type 不是这 3 种类型之一，那就会产生一个 option 预检请求，这时候需要添加设置才能支持跨域。</p><ol start="4"><li>没有回调函数，返回值为 true/false</li></ol><p>sendBeacon 返回 true 表示的是请求排队成功，等待下一步的执行。（下一步指的是啥，看下面的底层实现），返回 false 表示请求排队失败。</p><ol start="5"><li>兼容性就还可以，目前仅 IE 不支持</li></ol><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>sendBeacon 底层是通过 fetch 实现的。</p><p>在执行 sendBeacon 时，会按照以下 3 个步骤执行：</p><ol><li>检测数据量大小</li></ol><p>如果要发送的数据量大小超过限制则返回 false，否则进行下一步。</p><p>数据量大小限制：Chrome40-86 约 65536 个字符，数据大小的限制 64kb，这些是浏览器层面的限制，不同的浏览器可能还存在细微的差别。</p><ol start="2"><li>检测 mimeType 类型</li></ol><p>如果 mimeType 值不是 CORS 安全列出的请求标头值且是跨域的，则直接返回 false，否则进行下一步。</p><ol start="3"><li>发起 fetch 请求 它构造的 fetch 请求，参数如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">fetch(&#39;&#x2F;xxx&#39;,&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  method: &#39;POST&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  url:&#39;&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  keep-alive: true,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  body:transmittedData,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  mode:corsMode,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  credentials: &#39;include&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>可以注意到，Fetch API 支持一个 keep-alive 选项，</p><p>当设置为 true 时，保证不管发送请求的页面关闭与否，请求都会持续到结束。</p><p>credentials 设置为 include，即使是跨域调用，也总是携带 cookie。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写一个支持回调的 useState</title>
      <link href="/posts/424623501/"/>
      <url>/posts/424623501/</url>
      
        <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useStateWithCallBack</span>(<span class="params">initalState</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> [state, setState] = useState(initalState);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> setValueFunRef: any = useRef();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!setValueFunRef.current) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    setValueFunRef.current = <span class="function">(<span class="params">newState, callBack</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">console</span>.log(<span class="string">'newState'</span>, newState);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      setState(newState);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (callBack) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        callBack(newState);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(newState);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> [state, setValueFunRef.current];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>测试效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useStateWithCallBack(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> newCount = count + <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  setCount(newCount, c =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callback1'</span>, c);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  setCount(newCount).then(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callback2'</span>, c);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;, []);</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络缓存-强缓存与协商缓存</title>
      <link href="/posts/1708913293/"/>
      <url>/posts/1708913293/</url>
      
        <content type="html"><![CDATA[<h2 id="网络缓存-强缓存与协商缓存"><a href="#网络缓存-强缓存与协商缓存" class="headerlink" title="网络缓存-强缓存与协商缓存"></a>网络缓存-强缓存与协商缓存</h2><h3 id="什么是网络缓存"><a href="#什么是网络缓存" class="headerlink" title="什么是网络缓存"></a>什么是网络缓存</h3><hr><p>网络缓存位于一个或对个 web 服务器和一个或多个客户端之间，并监听请求的到来，保存响应的副本–如 HTML 页面，图像或文件。然后对同一 URL 有另一个请求时，浏览器就能使用之前保存过的副本，而不是再次向服务器请求它。</p><h3 id="为什么使用网络缓存"><a href="#为什么使用网络缓存" class="headerlink" title="为什么使用网络缓存"></a>为什么使用网络缓存</h3><hr><p>使用网络缓存有两个原因：</p><ul><li><strong><em>减少延迟</em></strong>– 因为请求的响应是从缓存中来的而不是服务器，所以它只需要更少的时间来获取响应并展示它</li><li><strong><em>减少网络流量</em></strong>– 因为是重用的，它减少了客户端使用的网络流量</li></ul><h3 id="缓存在哪儿"><a href="#缓存在哪儿" class="headerlink" title="缓存在哪儿"></a>缓存在哪儿</h3><hr><p>缓存分为 Memory Cache 和 Disk Cache。</p><h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>Memory Cache 就是缓存在内存中。资源放在内存中，如果浏览器关闭了那么内存中的资源也就释放了，所以它是个短期缓存。当访问过页面后，有的数据或资源就会放入内存中，比如 <code>图片、样式、脚本</code>等，<code>内存中的缓存数据读取比磁盘块</code>，所以像样式和图片这类的资源会优先使用 Memory Cache,这样读取速度快页面加载不容易卡顿。</p><p><img alt="memory-cache.png" data-src="/posts/1708913293/memory-cache.png" class="lazyload"></p><p>是不是能让数据都存放在内存中呢？</p><p>当然不行，因为内存的空间是有限的，系统要根据实际情况合理分配内存的使用，所以能使用内存的地方必然不多。</p><h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>Disk Cache 是将资源缓存再磁盘中。相比于内存缓存 Memory Cache，磁盘缓存容量就大得多了，但是读取速度会慢一点。所有的资源都可以缓存，特别是一些大文件，所以我们会看到有些脚本文件是放在内存中，有些是放到磁盘中的，内容容量有限放不下的时候数据就存放到磁盘中。</p><p><img alt="disk-cache.png" data-src="/posts/1708913293/disk-cache.png" class="lazyload"></p><p>Memory Cache 和 Disk Cache 其实都是浏览器强缓存策略的方式，不请求网络，直接从缓存中提取资源。</p><h4 id="不同行为执行缓存方式不同"><a href="#不同行为执行缓存方式不同" class="headerlink" title="不同行为执行缓存方式不同"></a>不同行为执行缓存方式不同</h4><ol><li>在地址栏中输入地址，主要是 disk cache, 如果没有再去请求服务器资源；</li><li>刷新网页（F5), 会根据当前运行环境内存来决定是从 Memory Cache 还是 Disk Cache 中取，优先取 Memory Cache，如果没找到再去 Disk Cache 内找；</li><li>强制属性（ctrl + F5), 从服务器请求资源，不使用缓存，所以加载时间会比较慢</li></ol><p>浏览器会把哪些文件缓存到内存中（Memory Cache),哪些缓存到磁盘中（Disk Cache)中呢？</p><ol><li>大文件一般都存储在磁盘中，小文件缓存再磁盘中；</li><li>当前系统内存使用率高的话，文件优先存储到磁盘中。</li></ol><h3 id="缓存有哪些类型"><a href="#缓存有哪些类型" class="headerlink" title="缓存有哪些类型"></a>缓存有哪些类型</h3><hr><p>有强缓存和协商缓存两种方式，区别在于强缓存的状态码是 200，且不会发送请求到服务器，直接从缓存获取。协商缓存的状态码是 304，会发送请求到服务器，通过服务器来告知缓存是否可用。</p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>强缓存分为 <code>Expries</code>(http1.0 规范) 和 <code>cache-control</code>(http1.1 规范) 两种。</p><h5 id="1-Expries"><a href="#1-Expries" class="headerlink" title="1. Expries"></a>1. Expries</h5><p>Expries 用于表示资源的过期时间的请求头字段，值是一个绝对时间，是由服务器端返回的。</p><p>在浏览器第一个请求资源时，服务器端的响应头上会附上 Expries 字段，当浏览器在下一次请求这个资源时会根据上次的 Expries 字段判断是否使用缓存资源。</p><blockquote><p>expries 是根据本地时间判断的，假设客户端和服务器时间不同，会导致缓存命中出现误差。</p></blockquote><h5 id="2-Cache-control"><a href="#2-Cache-control" class="headerlink" title="2. Cache-control"></a>2. Cache-control</h5><p>上面提到 Cache-control 会有误差的缺点，为了解决这个问题，在 http1.1 规范中提出了 Cache-control 字段，且<code>Cache-control 优先级高于 Expires</code>。</p><p>在 cache-control 中有几个常见的响应头：</p><table><thead><tr><th>属性值</th><th>值</th><th>备注</th></tr></thead><tbody><tr><td>max-age</td><td>3600</td><td>单位为秒，表示多少秒内不与服务器请求新的资源</td></tr><tr><td>s-maxage</td><td></td><td>和 max-age 一样，但这个是设置代理服务器的缓存时间</td></tr><tr><td>private</td><td></td><td>内容只缓存在私有缓存中（仅客户端可缓存，代理服务器不可缓存）</td></tr><tr><td>public</td><td></td><td>所以内容都将被缓存（客户端和代理服务器都可缓存）</td></tr><tr><td>no-store</td><td></td><td>不缓存任何数据</td></tr><tr><td>no-cache</td><td></td><td>储存在本地缓存区中，只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用</td></tr></tbody></table><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>在强缓存中，是否使用缓存是由浏览器确定的，而协商缓存则是由服务器来告诉浏览器是否使用缓存，也就是每一次都要发送请求到服务器询问是否使用缓存。具体流程如下：</p><blockquote><p>浏览器初次请求资源，服务器返回资源，同时生成一个 <code>Etag</code> 值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带 <code>If-None-Match</code>，值是之前服务器返回的 <code>Etag</code> 值，服务器收到之后拿该值与资源文件最新的 <code>Etag</code> 值做对比。</p></blockquote><ul><li>如果没有变化则返回 304，告诉浏览器继续使用缓存（不返回资源文件）。</li><li>如果发生变化，返回 200 和最新的资源文件给浏览器使用。</li></ul><p>除了 Etag 外还有一个 Last-Modified 属性，它是 http1.0 规范的，服务器返回 Last-Modified，浏览器请求头对应的携带的是 If-Modified-since，与 Etag 不同的是， Last-Modified 的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存。</p><p>相比 Last-Modified，Etag 的优先级更高，使用上也更精确，因为有时候会发生文件内容没变但文件的修改时间变了，这样会导致 Last-Modified 不一致而服务器会重新返回资源文件，但实际上还是可以使用缓存的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><ol><li><p>强缓存是浏览器本地根据服务器设置的过期时间判断是否使用缓存，未过期则不会发生请求到服务器，直接从本地加载。</p></li><li><p>协商缓存是浏览器发送请求询问服务器是否使用缓存，由服务器告知是从缓存里获取资源还是返回最新的资源给浏览器。</p></li><li><p>强缓存优先级大于协商缓存，两者同时存在时，如果强缓存开启了且还在有效期内，则不会走协商缓存。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSR介绍</title>
      <link href="/posts/708475590/"/>
      <url>/posts/708475590/</url>
      
        <content type="html"><![CDATA[<h2 id="SSR-介绍"><a href="#SSR-介绍" class="headerlink" title="SSR 介绍"></a>SSR 介绍</h2><h3 id="什么是-SSR"><a href="#什么是-SSR" class="headerlink" title="什么是 SSR"></a>什么是 SSR</h3><p>SSR 全称是<code>Server Side Render</code>，即服务端渲染，是指一种传统的渲染方式，就是在浏览器请求页面 url 的时候，服务端将我们需要的 HTML 文本组装好，并返回给浏览器，这个 HTML 文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面上。</p><p>SSR 有两种模式，单页面模式和多页面模式，第一种是后端首次渲染的单页面应用，第二种是完全使用后端路由的后端模板渲染模式，他们区别在于使用后端路由的程度。</p><h3 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h3><p>-</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 参数按值传递</title>
      <link href="/posts/3590049051/"/>
      <url>/posts/3590049051/</url>
      
        <content type="html"><![CDATA[<h2 id="js-参数按值传递"><a href="#js-参数按值传递" class="headerlink" title="js 参数按值传递"></a>js 参数按值传递</h2><p>在 《JavaScript 高级程序设计》中讲到:</p><blockquote><p>ECMAScript 中所有函数的参数都是<code>按值传递</code>的。</p></blockquote><p>什么是按值传递呢？</p><blockquote><p>意思就是把函数外部的值复制给函数内部的参数。</p></blockquote><h3 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h3><p>举个简单的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">v</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  v = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">fn(value); <span class="comment">// 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 1</span></span></pre></td></tr></table></figure><p>很好理解，当传递 value 到函数 fn 中时，相当于拷贝了一份 value，函数中修改的都是 value 的备份，而不会影响到原来的 value 值。</p><h3 id="引用传递？"><a href="#引用传递？" class="headerlink" title="引用传递？"></a>引用传递？</h3><p>但是当值是一个复杂的数据结构时，拷贝就会产生性能上的问题。</p><p>所有就有另一种传递方式叫<code>引用传递</code>。</p><p>所谓引用传递，就是传递对象的引用，函数内对参数的任何改变都会影响到对象的值，因为两者引用的是同一个对象。</p><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  value: <span class="number">1</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">o</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  o.value = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(o.value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">fn(obj); <span class="comment">// 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.value); <span class="comment">// 2</span></span></pre></td></tr></table></figure><p>不对啊，不是说所有参数都是<code>按值传递</code>的吗，这里怎么能按<code>引用传递</code>呢？</p><h3 id="第三种传递方式"><a href="#第三种传递方式" class="headerlink" title="第三种传递方式"></a>第三种传递方式</h3><p>再看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  value = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">o</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  o = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(o);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">fn(obj); <span class="comment">// 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.value); <span class="comment">// 1</span></span></pre></td></tr></table></figure><p>如果 js 采用的是引用传递，外层的值也会被改变，为什么这里没改呢？所以真的不是<code>引用传递</code>吗？</p><p>这就要讲到第三种传递方式<code>共享传递</code>。而共享传递指的是，在传递对象的时候，传递对象的引用的副本。</p><p>注意： <code>按引用传递的传递对象的引用，而按共享传递是传递对象的引用的副本！</code></p><p>所以修改 o.value 可以通过引用栈找到原值，但是直接修改 o, 并不会修改原值，所以第二个例子和第三个例子其实都是<code>共享传递</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>参数如果是基本类型是<code>按值传递</code>, 如果是引用类型是<code>按共享传递</code>。因为拷贝引用的副本也是一种值的拷贝，所以也被直接认为就是<code>按值传递</code>。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js词法作用域</title>
      <link href="/posts/2552693454/"/>
      <url>/posts/2552693454/</url>
      
        <content type="html"><![CDATA[<h2 id="js-词法作用域"><a href="#js-词法作用域" class="headerlink" title="js 词法作用域"></a>js 词法作用域</h2><h3 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h3><p>js 采用的是静态作用域，即<code>函数的作用域在函数定义的时候就决定了</code>。</p><p>先看下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> value = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  foo();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">bar();</span></pre></td></tr></table></figure><p>由于 js 采用的是静态作用域，所以上面这个例子会打印 1。</p><p>下面我们来分析下执行过程：</p><p>执行 foo 函数，先从 foo 函数内查找是否有局部变量 value，如果没有，就根据书写的位置查找上一层的代码，也就是 value 等于 1，故结果是 1。</p><h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>如果 js 采用的是动态作用域，那么执行过程应该是这样的：</p><p>执行 foo 函数，依然是从 foo 函数内查找是否有局部变量 value, 如果没有，就从调用函数的作用域就是 bar 函数内查找是否有局部变量 value, 所以结果是 2。</p><p>例如 bash 就是动态作用域。</p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>1.这是一个《 JavaScript 权威指南》中的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> scope;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> f();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(checkScope());</span></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> scope;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> f;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(checkScope()());</span></pre></td></tr></table></figure><p>上面两段代码最后都会打印： <code>local scope</code>。</p><ol start="2"><li>下面这个例子同样具有迷惑性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  a[<span class="number">100</span>] = <span class="number">100</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">f(a);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span></pre></td></tr></table></figure><p>上面输出结果是 [1, empty × 99, 100];</p><p>这是因为 js 函数参数是按传递，不是按引用传递的。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack5模板联邦初体验</title>
      <link href="/posts/2584961776/"/>
      <url>/posts/2584961776/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack5-模块联邦初体验"><a href="#webpack5-模块联邦初体验" class="headerlink" title="webpack5 模块联邦初体验"></a>webpack5 模块联邦初体验</h2><h3 id="1-什么是模块联邦"><a href="#1-什么是模块联邦" class="headerlink" title="1. 什么是模块联邦"></a>1. 什么是模块联邦</h3><p>webpack5 模块联邦(Module Federation) 主要是用来解决多个应用之间代码共享的问题，可以让我们更优雅的实现跨应用的代码共享。</p><p>假设现在我们有个需求，需要将 B 项目中的某个组件移植到 A 项目中，而且需要保证后续的迭代过程中，两边的组件保持一致。传统的做法有两种：</p><ol><li>CV 大法，将 B 项目中的组件代码拷贝到 A 组件中；</li><li>将 B 项目中的组件独立出来，发布 npm 包，A 项目中添加依赖；</li></ol><p>上面两种做法都有缺陷，首先 CV 大法不能实时同步代码，一旦组件需要更新，每次都需要复制粘贴。而 npm 包的做法首先需要将组件代码独立出来，然后每次更新都需要发布新的 npm 包，A 项目也需要每次更新依赖。</p><p>而现在通过模块联邦可以完美解决！</p><h3 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h3><p>首先准备两个项目，项目结构如下：</p><p>项目 A</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">├── public</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">│   └── index.html</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">├── src</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">│   ├── index.js</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">│   └── page.js</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">├── package.json</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">└── webpack.config.js</span></pre></td></tr></table></figure><p>项目 B</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">├── public</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">│   └── index.html</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">├── src</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">│   ├── index.js</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">│   └── components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">|       └──index.js</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">├── package.json</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">└── webpack.config.js</span></pre></td></tr></table></figure><p>在项目 B 中的 <code>components/index.js</code>里，导出两个组件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> button = <span class="built_in">document</span>.createElement(<span class="string">"button"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  button.textContent = <span class="string">"查询"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  button.style.backgroundColor = <span class="string">"#29bece"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  button.style.color = <span class="string">"#fff"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  button.style.border = <span class="string">"none"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">document</span>.body.appendChild(button);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> input = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  input.type = <span class="string">"number"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">document</span>.body.appendChild(input);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>在项目 B 的 <code>webpack.config.js</code>里，配置 <code>ModuleFederationPlugin</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ModuleFederationPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/container/ModuleFederationPlugin"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  mode: <span class="string">"development"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  devServer: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    port: <span class="number">9001</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  plugins: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">new</span> ModuleFederationPlugin(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      name: <span class="string">"boot"</span>, <span class="comment">// 唯一ID，用于标记当前服务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      filename: <span class="string">"remoteEntry.js"</span>, <span class="comment">// 提供给其他服务加载的文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      exposes: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"./components"</span>: <span class="string">"./src/components"</span>, <span class="comment">// 需要暴露的模块，使用时通过 `$&#123;name&#125;/$&#123;exposeKey&#125;` 引入</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      template: <span class="string">"./public/index.html"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  ],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><p>在项目 A 的 <code>webpack.config.js</code>中配置 <code>ModuleFederationPlugin</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ModuleFederationPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/container/ModuleFederationPlugin"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  mode: <span class="string">"development"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  devServer: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    port: <span class="number">9000</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  plugins: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">new</span> ModuleFederationPlugin(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      name: <span class="string">"app"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      remotes: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        boot: <span class="string">"boot@http://localhost:9001/remoteEntry.js"</span>, <span class="comment">// 引用 boot 的服务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      template: <span class="string">"./public/index.html"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  ],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><p>然后在项目 A 中的 <code>page.js</code>中引入项目 B 中的组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button, Input &#125; <span class="keyword">from</span> <span class="string">"boot/components"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Button();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Input();</span></pre></td></tr></table></figure><p>最后启动两个项目看下效果：<br><img alt="result.jpg" data-src="/posts/2584961776/result.jpg" class="lazyload"></p><p>大功告成！</p><h3 id="3-配置-shared"><a href="#3-配置-shared" class="headerlink" title="3. 配置 shared"></a>3. 配置 shared</h3><p>除了前面提到的模块引入和模块暴露相关的配置外，还有个 shared 配置，主要是用来避免项目出现多个公共依赖。</p><p>例如我们的项目 A, 已经引入了一个 <code>react / react-dom</code>, 而项目 B 暴露出来的组件也依赖了 <code>react / react-dom</code>。如果不解决这个问题, 项目 A 中就会加载两个 react。所以在使用模块联邦(Module Federation)的时候一定要记得，将公共依赖配置到 <code>shared</code>中，而且两个项目都要配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ModuleFederationPlugin(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">     name: <span class="string">"app"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">     remotes: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">       boot: <span class="string">"boot@http://localhost:9001/remoteEntry.js"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">     &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     shared: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">       react: &#123;<span class="attr">singleton</span>: <span class="literal">true</span>  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">       <span class="string">"react-dom"</span>: &#123; <span class="attr">singleton</span>: <span class="literal">true</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">   &#125;),</span></pre></td></tr></table></figure><h3 id="4-加载逻辑"><a href="#4-加载逻辑" class="headerlink" title="4. 加载逻辑"></a>4. 加载逻辑</h3><p>在项目 A 中需要特别注意，入口文件 <code>src/index.js</code>中本身是没有任何逻辑的，而是把逻辑放到了 <code>src/page.js</code>中，在 <code>index.js</code>中动态加载<code>page.js</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">"./page"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/page.js</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button, Input &#125; <span class="keyword">from</span> <span class="string">"boot/components"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Button();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Input();</span></pre></td></tr></table></figure><p>如果直接把逻辑放到 <code>src/index.js</code>中是会报错的：<br><img alt="error.jpg" data-src="/posts/2584961776/error.jpg" class="lazyload"></p><p>这是因为 remote 暴露的 js 文件需要优先加载，如果直接在 <code>index.js</code>中执行，此时的 <code>main.js</code>优先于 <code>remote.js</code>加载，而 <code>main.js</code> 中引用到的 <code>remote.js</code> 还没加载完，所以会有问题。</p><p>打开控制台可以看到 js 加载顺序：<br><img alt="network.jpg" data-src="/posts/2584961776/network.jpg" class="lazyload"></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>完整 demo 可以访问 <a href="https://github.com/panda-wind/module-federation-demo" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-大数据列表</title>
      <link href="/posts/259720668/"/>
      <url>/posts/259720668/</url>
      
        <content type="html"><![CDATA[<h2 id="React-大数据列表"><a href="#React-大数据列表" class="headerlink" title="React-大数据列表"></a>React-大数据列表</h2><h3 id="1-时间分片渲染"><a href="#1-时间分片渲染" class="headerlink" title="1. 时间分片渲染"></a>1. 时间分片渲染</h3><p>使用<code>setTimeout</code> 或者 <code>requestAnimateFrame</code>将一次性渲染全部数据分成若干次渲染，每次渲染一部分数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">40000</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sliceCount = <span class="number">100</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> <span class="built_in">Array</span>(count).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">_, index</span>) =&gt;</span> index + <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> [list, setList] = useState&lt;number[]&gt;([]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    sliceList(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> sliceList = <span class="function">(<span class="params">arr: number[]</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> sliceArr: number[] = arr.slice(<span class="number">0</span>, sliceCount);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (sliceArr.length &lt; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">      setList(<span class="function"><span class="params">prevList</span> =&gt;</span> [...prevList, ...sliceArr]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    sliceList(arr.slice(sliceCount));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &lt;div className=<span class="string">"list"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">      &#123;data.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        &lt;li className=<span class="string">"list-item"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">          &#123;<span class="string">`item-<span class="subst">$&#123;item&#125;</span>`</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &lt;<span class="regexp">/li&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      ))&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span></pre></td></tr></table></figure><h3 id="2-虚拟列表"><a href="#2-虚拟列表" class="headerlink" title="2. 虚拟列表"></a>2. 虚拟列表</h3><p>虚拟列表是按需显示的一种思路，根据用户的滚动，计算出需要渲染展示的数据，从而达到只渲染可视区域内的一部分，而不必渲染全部数据的效果。</p><p>虚拟列表分为渲染区、缓存区和虚拟列表区。</p><p>为了防止大量 dom 存在影响性能，我们只对渲染区和缓冲区的数据做渲染，虚拟列表区没有真实的 dom 存在。缓冲区的作用就是防止快速下滑或者上滑过程中，会有空白的现象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Checkbox &#125; <span class="keyword">from</span> <span class="string">"choerodon-ui"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./index.less"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contentHeight = <span class="number">500</span>; <span class="comment">// 区域总高度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itemHeight = <span class="number">32</span>; <span class="comment">// 单条数据高度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">40000</span>).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">_, index</span>) =&gt;</span> index + <span class="number">1</span>); <span class="comment">// 模拟大数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">interface IState &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  start: number;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  end: number;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  bufferCount: number;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  renderCount: number;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">any</span>, <span class="title">IState</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  listRef: any = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  state = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    start: <span class="number">0</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    end: <span class="number">0</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    bufferCount: <span class="number">8</span>, <span class="comment">// 缓冲区个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    renderCount: <span class="number">0</span>, <span class="comment">// 当前渲染区总个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  componentDidMount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 处理第一次展示的数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> &#123; bufferCount &#125; = <span class="keyword">this</span>.state;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> renderCount = <span class="built_in">Math</span>.floor(contentHeight / itemHeight) + bufferCount;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.setState(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">      renderCount,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">      end: renderCount + <span class="number">1</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  renderItem = <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"list-item"</span>&gt;</span>&#123;`item-$&#123;item&#125;`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">  handleScroll = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> &#123; renderCount &#125; = <span class="keyword">this</span>.state;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> &#123; scrollTop &#125; = e.target;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> start = <span class="built_in">Math</span>.floor(scrollTop / itemHeight);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> currentOffset = scrollTop - (scrollTop % itemHeight);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* translate3d 开启css cpu 加速 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.listRef.style.transform = <span class="string">`translate3d(0, <span class="subst">$&#123;currentOffset&#125;</span>px, 0)`</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> end = <span class="built_in">Math</span>.floor(scrollTop / itemHeight) + renderCount + <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.setState(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">      start,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">      end,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">  shouldComponentUpdate(_nextProps, _nextState) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">      _nextState.start !== <span class="keyword">this</span>.state.start || _nextState.end !== <span class="keyword">this</span>.state.end</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> &#123; start, end &#125; = <span class="keyword">this</span>.state;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 只渲染需要展示的数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> renderList = data.slice(start, end);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">      &lt;div</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">        style=&#123;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">          height: contentHeight,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">          overflow: <span class="string">"auto"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">          position: <span class="string">"relative"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">        &#125;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">        onScroll=&#123;<span class="keyword">this</span>.handleScroll&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">      &gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        &#123;<span class="comment">/* 占位区 */</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">        &lt;div</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">          style=&#123;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">            height: itemHeight * data.length,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">            position: <span class="string">"absolute"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">            top: <span class="number">0</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">            left: <span class="number">0</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">            right: <span class="number">0</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">            backfaceVisibility: <span class="string">"hidden"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">            perspective: <span class="number">1000</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">          &#125;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">        /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">        &#123;<span class="comment">/* 渲染区 */</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">        &lt;div</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">          ref=&#123;(el) =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.listRef = el;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">          &#125;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">          style=&#123;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">            height: contentHeight,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">            position: <span class="string">"relative"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">            top: <span class="number">0</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">            left: <span class="number">0</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">            right: <span class="number">0</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">          &#125;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">        &gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">          &#123;renderList.map(<span class="keyword">this</span>.renderItem)&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">        &lt;<span class="regexp">/div&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span></pre></td></tr></table></figure><h3 id="3-使用-react-tiny-virtual-list-插件"><a href="#3-使用-react-tiny-virtual-list-插件" class="headerlink" title="3. 使用 react-tiny-virtual-list 插件"></a>3. 使用 react-tiny-virtual-list 插件</h3><p><code>react-tiny-virtual-list</code>是一个较为轻量的实现虚拟列表的组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VirtualList <span class="keyword">from</span> <span class="string">'react-tiny-virtual-list'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">40000</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sliceCount = <span class="number">100</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> <span class="built_in">Array</span>(count).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">_, index</span>) =&gt;</span> index + <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> [list, setList] = useState&lt;number[]&gt;([]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    sliceList(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> sliceList = <span class="function">(<span class="params">arr: number[]</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> sliceArr: number[] = arr.slice(<span class="number">0</span>, sliceCount);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (sliceArr.length &lt; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">      setList(<span class="function"><span class="params">prevList</span> =&gt;</span> [...prevList, ...sliceArr]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    sliceList(arr.slice(sliceCount));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &lt;VirtualList</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">      width=<span class="string">"100%"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      height=&#123;<span class="number">300</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">      itemCount=&#123;data.length&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">      itemSize=&#123;<span class="number">50</span>&#125; <span class="comment">// Also supports variable heights (array or function getter)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">      renderItem=&#123;(&#123; index, style &#125;) =&gt; (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &lt;div key=&#123;index + <span class="number">1</span>&#125; style=&#123;style&#125;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">          &#123;<span class="string">' '</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">          <span class="comment">// The style property contains the item's absolute position Letter: &#123;data[index + 1]&#125;,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">          Row: #&#123;index&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &lt;<span class="regexp">/div&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      )&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    /</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Scheduler为什么使用Message Channel实现呢？</title>
      <link href="/posts/1746973508/"/>
      <url>/posts/1746973508/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Scheduler-为什么使用-Message-Channel-实现呢？"><a href="#React-Scheduler-为什么使用-Message-Channel-实现呢？" class="headerlink" title="React Scheduler 为什么使用 Message Channel 实现呢？"></a>React Scheduler 为什么使用 Message Channel 实现呢？</h2><p>###1.Scheduler 简介<br>如果「组件 render 过程耗时」或「参与调合阶段的虚拟 DOM 节点很多」时，那么一次性完成所有组件的调合阶段机会花费很多时间。</p><p>为避免长时间执行调合阶段而引起页面卡顿，React 团队提出来<code>Fiber</code>架构和 <code>Scheduler</code>任务调度。</p><p>Fiber 架构的目的是「能独立执行每个虚拟 DOM 的调合阶段」， 而不是每次执行整个虚拟 DOM 树的调合阶段。</p><p>Scheduler 的主要功能是时间分片，每隔一段时间就把主线程还给浏览器，避免长时间占用主线程。</p><p>###2.React 和 Scheduler 交互<br>如果只考虑 React 和 Scheduler 的交互，则组件的更新流程如下：</p><ol><li>React 组件状态更新，向 Scheduler 中存入一个任务，该任务为 React 更新算法。</li><li>Scheduler 调度该任务，执行 React 更新算法。</li><li>React 在调合阶段更新一个 Fiber 之后，会询问 Scheduler 是否需要暂停。如果不需要暂停，则重复步骤 3，继续更新下一个 Fiber。</li><li>如果 Scheduler 表示需要暂停，则 React 会返回一个函数，该函数用于告诉 Scheduler 任务还没有完成，将来还需要调度它。</li></ol><p>该流程可以用伪代码表达：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Scheduler = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  pushTask() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 1.存入任务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  schedulerTask() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 2. 挑选一个任务并执行</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> task = pickTask();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> hasMoreTask = task();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (hasMoreTask) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 4. 将来继续执行</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  shouldYeild() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 3. 由调用方调用，调用方判断是否需要暂停</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设一个场景，用户点击时修改了组件状态</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// React 组件更新时，产生任务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> task = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> fiber = root;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (!scheduler.shouldYield() &amp;&amp; fiber) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// reconciliaiton 对当前 fiber 执行调和阶段,并返回下一个 fiber</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      fiber = reconciliation(fiber)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  scheduler.pushTask(task);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// React 在某一个时刻执行 scheduler.schedulerTask方法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  scheduler.schedulerTask();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><p>###3.设计 Scheduler<br>我们可以将 Scheduler 的调度方式理解为： <code>当前执行函数返回执行权给调用方，调用方可以在将来继续执行该函数</code>。这种调度方式与生成器函数(generator function)的功能一模一样。但 React 团队并没有使用生成器函数实现，主要原因是生成器函数是有状态的，而 React 团队想要的是无状态的。「<a href="https://github.com/facebook/react/issues/7942#issuecomment-254987818" target="_blank">官方解释</a>」</p><p>Scheduler 实现的关键点在于 当 Scheduler.shouldYeild 返回 true 时， Scheduler 需要满足两点：</p><ol><li>暂停 js 执行，将主线程还给浏览器，让浏览器有机会更新页面。</li><li>在未来某个时刻继续调度任务，执行上次没有完成的任务。</li></ol><p>要满足这两点就需要调度一个宏任务，<code>因为宏任务是在下次事件循环中执行，不会阻塞本次更新页面</code>。而微任务是在本地页面更新前执行，与同步无异，不会让出主线程。</p><p><code>使用 MessageChannel 的目的就是产生一个宏任务。</code></p><p>###4.为什么不用 setTimeout 呢</p><p>setTimeout 是最常用的创建宏任务的手段，为什么 React 没选择用呢？</p><p>原因就是在递归执行 setTimeout 的时候，最后间隔时间会变成 4 毫秒，而不是最初的 1 毫秒，我们可以用下面的代码测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = + <span class="keyword">new</span> <span class="built_in">Date</span>();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setTimeout</span>(<span class="params">(</span>) =&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用AbortController中断请求</title>
      <link href="/posts/592624706/"/>
      <url>/posts/592624706/</url>
      
        <content type="html"><![CDATA[<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p><strong><em>构造函数创建对象</em></strong><br>我们先使用构造函数创建一个对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">person.name = <span class="string">'zhangsan'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// zhangsan</span></span></pre></td></tr></table></figure><p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p><p><strong><em>prototype</em></strong><br>每个函数都有一个 prototype 属性，而且 prototype 是函数才有的属性。那这个函数的 prototype 属性到底指向的是什么呢？ 是这个函数的原型吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">'xxx'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// xxx</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// xxx</span></span></pre></td></tr></table></figure><p>其实函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是上面这个例子中的 person1 和 person2的原型。</p><p>那什么是原型呢？ 可以这样理解：<code>每个js对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性。</code></p><p><img alt="prototype1.png" data-src="/posts/592624706/prototype1.png" class="lazyload"></p><p>那么 person 和 Person.prototype 之间的关系是什么呢？这里就要说到 <em>proto</em> 了。</p><p><strong><em><em>propto</em></em></strong></p><p>这是每个js对象（null除外）都具有的一个属性，叫 <em>proto</em> ， 这个属性会指向该对象的原型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function Person() &#123; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">var person &#x3D; new Person();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">console.log(person._proto_ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span></pre></td></tr></table></figure><p><img alt="prototype2.png" data-src="/posts/592624706/prototype2.png" class="lazyload"></p><p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或实例呢？</p><p><strong><em>constructor</em></strong><br>指向实例倒是没有，因为一个构造函数可以生成很多个实例，但原型指向构造函数倒是有，这就要说到 constructor 了。每个原型都有一个 constructor 属性指向关联的构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true</span></span></pre></td></tr></table></figure><p><img alt="prototype3.png" data-src="/posts/592624706/prototype3.png" class="lazyload"></p><p>了解了构造函数，实例原型和实例之间的关系，接下来我们讲讲实例和原型的关系：</p><p><strong><em>实例和原型</em></strong><br>当读取实例的属性时，如果找不到就会查找与实例关系的原型中的属性，如果还找不到，就去找原型的原型，一直找到顶层为止.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">'zhangsan'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// zhangsan</span></span></pre></td></tr></table></figure><p><strong><em>原型的原型</em></strong></p><p>在前面，我们讲到原型也是一个对象，其实原型对象就是通过 Object 构造函数生成的，结合之前讲的，对象 <em>proto</em> 指向 构造函数的 prototype，所以关系图可以更新为：</p><p><img alt="prototype4.png" data-src="/posts/592624706/prototype4.png" class="lazyload"></p><p><strong><em>原型链</em></strong></p><p>那 Object.prototype 的原型呢？</p><p>我们可以打印下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype._proto_); <span class="comment">// null</span></span></pre></td></tr></table></figure><p>Object.protype._proto_的值为null，即没有原型。所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p><p><img alt="prototype5.png" data-src="/posts/592624706/prototype5.png" class="lazyload"></p><p>图中由相互关联的原型组成的链状结构就是原型链，也就是图中蓝色的线。</p><p><strong><em>补充</em></strong></p><p><strong><strong><em>proto</em></strong></strong><br>其实并不存在 Person.prototype 中，实际上它是来自 Object.prototype 中，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<em>proto</em> 时，可以理解为返回了 Object.getPrototypeOf(obj)</p><p><strong><strong>真的是继承吗</strong></strong></p><p>前面我们讲到 每一个对象都会从原型上’继承’属性，实际上，继承是一个十分具有迷惑性的说法，因为继承意味着复制操作，但是js默认并不会复制对象的属性，js只是在两个对象创建一个关联。这样一个对象就可以通过委托的方式访问另一个对象的属性，所以叫委托更准确些。</p><p><strong><strong>为什么Function.proto等于Function.prototype</strong></strong></p><p>MDN上关于这个的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="noopener">解释</a>是：<code>_proto_的读取器（gettet/setter)暴露了一个对象的内部[prototype]。对于使用对象字面量创建的对象，这个值是Object.prototype,对于使用数组创建的对象，这个值是Array.prototype。对于functions,这个值是Function.prototype。对于使用new fun创建的对象，其中fun是使用js提供的内建构造器之一（Array、Boolean、Date、Number、Object、String等），这个值是fun.prototype。而对于用js定义的其他js构造器函数创建的对象，这个值是该构造函数的prototype属性。</code></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程 (process) 和线程 (thread)</title>
      <link href="/posts/158612386/"/>
      <url>/posts/158612386/</url>
      
        <content type="html"><![CDATA[<h2 id="一道有趣的JS存储题"><a href="#一道有趣的JS存储题" class="headerlink" title="一道有趣的JS存储题"></a>一道有趣的JS存储题</h2><p><strong><em>从一道题目开始</em></strong></p><p>首先看一道经典的关于JS存储的题目：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">a.x = a = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);·</span></pre></td></tr></table></figure><p>想必大家心中都有答案了 … 但结果很显然是有趣的：</p><p><img alt="output.png" data-src="/posts/158612386/output.png" class="lazyload"></p><p>怎么会是undefined？不是赋值了吗？接下来仔细分析一下：</p><p><strong><em>分析</em></strong></p><p>我们先改下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">a.x &#x3D; a &#x3D; &#123;n:2&#125;;  ---- &gt; a &#x3D; a.x &#x3D; &#123;n:2&#125;;</span></pre></td></tr></table></figure><p>改完之后会发现，无论是先给a赋值还是先给 a.x 赋值结果都是一样的。</p><p>查了一些资料后得知，<code>等式中.的优先级是最高的</code>。</p><p>所以上题中，</p><ol><li><p>a.x无论是先赋值还是后赋值都会首先被创建出来，</p></li><li><p>然后执行赋值操作 a.x 指向 {n:2}</p></li><li><p>然后再执行赋值操作，a 指向 {n:2}。此时，a新指向的对象中没有 x 这个属性，所以 a.x 输出 undefined</p></li></ol><p><strong><em>深度解析</em></strong></p><p><code>JS会把变量存到栈中，而对象则会存在堆中。</code></p><ol><li><p>第一行代码，变量 a 的指针指向堆栈；</p></li><li><p>第二行代码： a.x = a = {n:2}, 堆1中的变量的 x 变量指向堆2中的{n:2}, 接着给 a 赋值{n:2}, a的指针被改变指向堆2，然后<br>堆1没有被指针指向，被GC回收，因此输出的 a.x 是 undefined 而 a 的值是{n:2}。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暂时性死区和作用域</title>
      <link href="/posts/3495248571/"/>
      <url>/posts/3495248571/</url>
      
        <content type="html"><![CDATA[<h2 id="暂时性死区和作用域"><a href="#暂时性死区和作用域" class="headerlink" title="暂时性死区和作用域"></a>暂时性死区和作用域</h2><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>在代码块内，使用<code>let</code>和<code>const</code>声明变量之前，该变量读是不可用的，这在语法上，称为<code>暂时性死区</code>。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-js篇</title>
      <link href="/posts/3271247989/"/>
      <url>/posts/3271247989/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题-js篇"><a href="#面试题-js篇" class="headerlink" title="面试题-js篇"></a>面试题-js篇</h2><h3 id="var、let和const的区别"><a href="#var、let和const的区别" class="headerlink" title="var、let和const的区别"></a>var、let和const的区别</h3><p>  从三个方面说：</p><ul><li><strong>变量提升</strong>： var声明的变量存在变量提升，即变量在声明前调用，值为undefined。let和const其实也有，但是let和const具有暂时性死区的概念，即没有赋值之前不能使用，否则会报错。故不存在变量提升问题。</li><li><strong>块级作用域</strong>： var不存在块级作用域，let和const存在块级作用域。</li><li><strong>声明</strong>： var允许重复声明变量，let和const在同一作用域内不允许重复声明。其中const声明的是一个只读的变量（所以const声明的变量一定要在声明的时候就赋值，不然会报错）。</li></ul><h3 id="如何使const声明的对象内的属性不可变，只可读呢？"><a href="#如何使const声明的对象内的属性不可变，只可读呢？" class="headerlink" title="如何使const声明的对象内的属性不可变，只可读呢？"></a>如何使const声明的对象内的属性不可变，只可读呢？</h3><p>  由于在js中声明的对象只是保存其对象的<strong>引用地址</strong>，只要地址不变，就不会报错。所以使用const声明的对象，对象内的属性是可以改变的。</p><p>  通过以下两种方法可以使const声明的对象内的属性不可变，只可读：</p><ol><li><p>使用<code>Object.freeze(obj)</code>冻结obj对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  name: <span class="string">'zs'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.freeze(person);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">person.name = <span class="string">'ls'</span>; <span class="comment">// 会报错</span></span></pre></td></tr></table></figure></li><li><p>使用<code>Object.defineProperty</code>设置对象的<code>writable</code>属性为false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  name: <span class="string">'zs'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  writable: <span class="literal">false</span>, <span class="comment">// 表示能否修改属性的值,默认为true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">person.name = <span class="string">'ls'</span>; <span class="comment">// 会报错</span></span></pre></td></tr></table></figure><p>但是这两种方法都有局限性，如果obj对象内的属性值如果也是个对象的话，则限制不了其只读。要想全不可变，就需要使用递归等一层层冻结了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  age: <span class="number">25</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  name: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    firstName: <span class="string">'zhang'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    lastName: <span class="string">'san'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  writable: <span class="literal">false</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.freeze(person);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">person.name.lastName = <span class="string">'liang'</span>; <span class="comment">// 不会报错，值会被修改</span></span></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>console.log是异步的吗</title>
      <link href="/posts/1196284200/"/>
      <url>/posts/1196284200/</url>
      
        <content type="html"><![CDATA[<h2 id="console-log是异步的吗"><a href="#console-log是异步的吗" class="headerlink" title="console.log是异步的吗"></a>console.log是异步的吗</h2><h3 id="先看一个’bug’"><a href="#先看一个’bug’" class="headerlink" title="先看一个’bug’"></a>先看一个’bug’</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> b = &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    c: <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  b.c++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>按照惯性思维，我们觉得打印操作在自增操作之前，所以说打印结果应该为{b: 1}，但实际上是这样的：</p><p><img alt="1.jpg" data-src="/posts/1196284200/1.jpg" class="lazyload"></p><p>会不会觉得很奇怪，为什么打印的确实是<code>{ c: 1 }</code>，但展开以后显示的却是<code>{ c: 2 }</code>？</p><h3 id="console-log的打印原理"><a href="#console-log的打印原理" class="headerlink" title="console.log的打印原理"></a>console.log的打印原理</h3><p>在《你不知道的javascript中卷》中有关控制台的部分中写道：</p><blockquote><p>并没有什么规范或一组需求指定console.*方法族怎么工作——他们并不是JavaScript正式的一部分，而是由宿主环境添加到JavaScript中的，因此，不同浏览器和JavaScript环境可以根据自己的意愿来实现，有时候这会引起混淆。<br>尤其要提出的是，在某些条件下，某些浏览器的console.log(…)并不会把传入的内容立即输出。出现这种情况的主要原因是，在许多程序（不只是JavaScript）中，I/O是非常低速的阻塞部分。所以，（页面UI的角度来说）浏览器在后台异步处理控制台I/0能给提高性能，这时用户甚至可能根本意识不到其发生。</p></blockquote><p>通俗点来说，console.log实际上不是所谓的”异步打印”，只是打印的过程给人感觉像是异步的。</p><p>拿上面的例子来说，当浏览器读到<code>console.log(b)</code>时，控制台会立即打印引用的快照，快照类似于调用了一次<code>JSON.stringify()</code>，将对象序列成一个字符串中展示。</p><p>打印引用的快照以后，将继续执行<code>console.log(b)</code>以后的代码，而之后遇到<code>b.c++</code>，于是对象b的属性c的值就自增变成了2。而当我们展开打印内容时，才会去这个引用的地址取的内容，并展示出来，所以会给人一种异步打印的错觉。其实<code>console.log()</code>仍然是一个同步操作。</p><p>我们用一个例子验证下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function a() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  var b &#x3D; &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    c: 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  console.log(b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    console.log(b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    b.c++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;, 5000);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>我们在原来的例子基础上加了个<code>setTimeout</code>，让程序执行5秒后再执行<code>console.log</code>。我们在5秒前把第一个<code>console.log</code>的打印结果展开看看会是什么结果:</p><p><img alt="2.jpg" data-src="/posts/1196284200/2.jpg" class="lazyload"></p><p>我们会发现第一个<code>console.log</code>展开之后值依然是<code>{c: 1}</code>，第二个<code>console.log</code>结果就是正常的了。</p><p>这是因为在5秒内点开第一个<code>consoel.log</code>的打印内容时，还没执行自增操作，所以此时引用的值还是1，而5秒之后的第二次<code>console.log</code>，打印内容就和我们预想的一样了。</p><blockquote><p>其中这种看起来像异步的打印，不仅是对条件有限制（比如打印的是一个引用数据类型）,对浏览器也有限制（老板的ie会直接把整个引用的地址的内容打印出来）。但是从某些方面来说，这也算是对浏览器的一种优化。<br>为什么说是种优化呢，试想一下，如果你打印的引用地址内的参数非常多，并且打印次数也很多时，无数次的打印，对浏览器的消耗也会非常大。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>当我们在调试的过程中使用了控制台打印，发现打印结果的快照和展开之后的内容不一致时，需要意识到，这是浏览器I/O的异步化造成的。</li><li>遇到这种情况，最好在调试器中打断点调试，如果嫌断点麻烦，就直接使用<code>JSON.stringify</code>打印快照。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件冒泡、事件捕获和事件委托(事件代理)</title>
      <link href="/posts/3367743277/"/>
      <url>/posts/3367743277/</url>
      
        <content type="html"><![CDATA[<h2 id="事件冒泡、事件捕获和事件委托-事件代理"><a href="#事件冒泡、事件捕获和事件委托-事件代理" class="headerlink" title="事件冒泡、事件捕获和事件委托(事件代理)"></a>事件冒泡、事件捕获和事件委托(事件代理)</h2><p>事件冒泡和事件捕获是分别由微软和网景公司提出的，都是为了解决页面事件流（事件发生顺序）的问题。</p><p>比如有下面一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr></table></figure><p>上面一段代码描述的是一个div元素当中有一个p子元素，如果给这两个元素都加上点击事件，那么我们怎么知道哪一个函数会首先被触发呢？</p><p>为了解决这个问题， 微软和网景公司提出了两种完全相反的概念。</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>微软提出了名为事件冒泡的事件流。事件冒泡可以形象的比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面，也就是说，事件会从内层的元素开始发生，一直向上传播，直到顶层的document对象。</p><p>因此上面的例子中，在事件冒泡的概念下发生点击事件的顺序应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">p -&gt; div -&gt; body -&gt; html -&gt; document</span></pre></td></tr></table></figure><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>网景公司提出了另一种事件流，名为事件捕获。恰恰与事件冒泡相反，事件会从最外层开始发生，直到最里面的元素。</p><p>因此上面的例子中，在事件捕获的概念下发生点击事件的顺序应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">document -&gt; html -&gt; body -&gt; div -&gt; p</span></pre></td></tr></table></figure><h3 id="addEventListener的第三个参数"><a href="#addEventListener的第三个参数" class="headerlink" title="addEventListener的第三个参数"></a>addEventListener的第三个参数</h3><p><code>DOM2级事件</code>中规定的事件流同时支持了事件冒泡阶段和事件捕获阶段，作为开发者，我们可以选择事件处理函数在哪一个阶段被调用。</p><p><code>addEventListener</code>方法用来为一个特点的元素绑定一个事件处理函数，有三个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">element.addEventListener(event, <span class="function"><span class="keyword">function</span>, <span class="title">useCapture</span>);</span></span></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>event</td><td>必须。字符串，指定事件名</td></tr><tr><td>function</td><td>必须。指定事件触发时要执行的函数</td></tr><tr><td>useCapture</td><td>可选。布尔值，指定事件是在捕获阶段还是冒泡阶段执行。true表示捕获阶段，false表示冒泡阶段。默认为false。</td></tr></tbody></table><h3 id="事件委托-事件代理"><a href="#事件委托-事件代理" class="headerlink" title="事件委托(事件代理)"></a>事件委托(事件代理)</h3><p>利用事件流的特性，在开发中，我们可以使用一种事件委托(事件代理)的方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"color_list"</span>&gt;</span>        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>red<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>yellow<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>green<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>blue<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>purple<span class="tag">&lt;/<span class="name">li</span>&gt;</span>    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></pre></td></tr></table></figure><p>我们想要在点击每个li标签的时候，输出当前点击的li的颜色。</p><p>常规做法是变量每个li，然后在每个li上绑定一个点击事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color_list = <span class="built_in">document</span>.querySelector(<span class="string">'.color_list'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = color_list.getElementsByTagName(<span class="string">'li'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; colors.length; n++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  colors[n].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这种做法当li标签个数少的时候还可以使用，万一li的数量较多时，无疑会对性能造成影响。</p><p>利用事件流的特性，我们可以只在父元素ul标签上绑定一个事件处理函数就可以可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color_list = <span class="built_in">document</span>.querySelector(<span class="string">'.color_list'</span>); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">color_list.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event; <span class="comment">// 兼容性处理</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (e.target.nodeName.toLowerCase() === <span class="string">'li'</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(e.target.innerHTML);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>由于事件冒泡机制，点击了l后会冒泡到ul，此时就会触发绑定在ul上的点击事件，再利用event.target找到事件实际发生的元素，就可以达到预期的效果。</p><p>上面这种做法就是<code>事件委托(事件代理)</code>。</p><p>使用<code>事件委托(事件代理)</code>的好处不仅在于将多个事件处理函数减成一个，而且对于不用元素可以有不同的处理方法。假如上述列表元素当中添加了其他的元素节点(如span，a等)，我们不必再一次循环给每个元素绑定事件，直接修改事件代理的事件处理函数即可。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><p>冒泡还是捕获？</p><p>对于事件代理来说，在事件冒泡还是事件捕获阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件模型被所有主流浏览器兼容，从兼容性角度来说还是建议大家使用<code>事件冒泡</code>。</p></li><li><p>IE浏览器兼容</p><p>IE浏览器对<code>addEventlistener</code>兼容性并不好，只有IE9以上才支持。要兼容旧版本的IE浏览器，可以使用IE的<code>attachEvent函数</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">object.attachEvent(event, <span class="function"><span class="keyword">function</span>);</span></span></pre></td></tr></table></figure><p>两个参数和<code>addEventListener</code>相似，分别是事件和处理函数，默认是事件冒泡阶段调用处理函数。</p></li><li><p>阻止事件冒泡</p><p>(1) 给子元素加event.stopPropagation()</p><p>(2) 在事件处理函数中返回false。</p><p>2和1是有区别的。<code>return false</code>不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。<code>event.stopPropagation</code>则只阻止事件往上冒泡，不阻止事件本身。</p><p>(3) event.target === event.currentTarget，让事件触发的元素等于绑定事件的元素，也可以阻止事件冒泡。</p></li><li><p>阻止默认事件</p><p>(1) event.preventDefault()</p><p>(2) return false</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React合成事件</title>
      <link href="/posts/3640873551/"/>
      <url>/posts/3640873551/</url>
      
        <content type="html"><![CDATA[<h2 id="React合成事件"><a href="#React合成事件" class="headerlink" title="React合成事件"></a>React合成事件</h2><p><strong>一.前言</strong></p><p><strong><em>1.先想想几个问题</em></strong></p><ul><li>我们写的事件是绑定在 dom 上吗？如果不是那么事件绑定在哪里去了？</li><li>为什么我们的事件需要手动绑定 this ？（不是箭头函数的情况）</li><li>为什么不能用<code>return false</code>来阻止事件的默认行为？</li></ul><p><strong><em>2.我们在JSX中定义的事件最终会变成什么</em></strong></p><p>  下面是一段含有点击事件的JSX代码：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'handle click'</span>); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span>(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;按钮&lt;<span class="regexp">/button&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    )</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure><br>  经过 babel 转换后，代码变成这样：<br>  <img alt="1.jpg" data-src="/posts/3640873551/1.jpg" class="lazyload"></p><p>  接下来在浏览器中，看看<code>&lt;button&gt;</code>这个元素上有没有绑定 onClick 事件呢？<br>  <img alt="2.jpg" data-src="/posts/3640873551/2.jpg" class="lazyload"></p><p>  从上图中我们会发现，<code>button</code>上绑定了两个事件，一个是<code>document</code>上的事件监听器，另一个是<code>button</code>。而<code>button</code>上的没有看到我们的<code>handleClick</code>事件, 而是<code>handle</code>。而且这个<code>handle</code>指向的是一个空函数。<br>  <img alt="3.jpg" data-src="/posts/3640873551/3.jpg" class="lazyload"></p><p>  接着再看<code>document</code>绑定事件：<br>  <img alt="4.jpg" data-src="/posts/3640873551/4.jpg" class="lazyload"></p><p>  可以看到 click 事件被绑定到<code>document</code>上了。</p><p>  所以我们可以得出结论：  </p><ul><li>我们在 jsx 中绑定的事件根本没有注册到真是的 dom上，而是采用<code>事件冒泡</code>的形式冒泡到document上面，然后 react 将事件封装到正式的函数处理。</li><li>真实 dom 上的 click 事件被 react 底层处理成空函数了。</li><li>react 并不是一开始把所有的事件都绑定在 document上，而是采取了一种按需绑定的策略了，比如发下了 onClick 事件，再去绑定 document click 事件。</li></ul><p><strong>二. 合成事件</strong></p><p>在 react 中，我们绑定的事件如 <code>onClick</code> 等，都不是原生事件，而是由原生事件合成的 react 事件，比如 <code>click</code> 事件合成为 <code>onClick</code> 事件，<code>blur</code>、 <code>change</code>、 <code>input</code>、<code>keydown</code> 等合成为 <code>onChange</code>。</p><p>那么为什么 react 要采用这种事件合成模式呢？</p><ol><li>减少内存消耗，提高性能。一种事件类型只在 document 上注册一次，不需要注册那么多次事件了。如果 DOM 上绑定了过多的事件处理函数，整个页面的响应速度以及内存占用可能都会受到影响。</li><li>统一规范，兼容各个浏览器。</li></ol><p>那么 react 是如何处理事件合成的呢？</p><p>下面从三个部分来解析：</p><ol><li>react 对事件是如何合成的。</li><li>react 事件是怎么绑定的。</li><li>react 事件触发流程。</li></ol><p><strong>三. 事件初始化</strong></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程 (process) 和线程 (thread)</title>
      <link href="/posts/158612386/"/>
      <url>/posts/158612386/</url>
      
        <content type="html"><![CDATA[<h2 id="进程-process-和线程-thread"><a href="#进程-process-和线程-thread" class="headerlink" title="进程 (process) 和线程 (thread)"></a>进程 (process) 和线程 (thread)</h2><p>进程和线程是操作系统的基本概念。</p><p><strong><em>1. 概念</em></strong></p><p>进程是CPU资源分配的最小单位（是拥有资源和独立运行的最小单位）。<br>线程是CPU调度的最小单位（是建立在进程上的一次程序运行单位）。</p><p><strong><em>2. 举例</em></strong></p><p>对于浏览器来说，打开一个Word就是打开一个进程，Word支持同时进打字、拼写检查、打印等事情。在一个进程内部要做多件事情，就需要同时运行多个子任务，这些子任务就叫做<code>线程</code>。</p><p>由于一个进程内部至少要做一件事情，所以<code>一个进程至少有一个线程</code>。系统会给每个进程分配独立的内存，因此进程有它独立的资源。同一进程内的各个线程之间共享该进程的内存空间。</p><p>用一个生动的比喻来说，进程就是一像一个有边界的生产厂间，而线程就像厂间内的一个个员工，可以自己做自己的事情，也可以相互配合做同一件事情。</p><p>当我们启用一个应用时，计算机会创建一个进程，操作系统会为进程分配一部分内存，应用的所有状态都会保存在这块内存中。</p><p>应用也许会创建多个线程来辅助工作，这些进程可以共享这部分内存中的数据，如果应用关闭，进程会被关闭，操作系统会释放相关内存。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中==和===的原理</title>
      <link href="/posts/1570400975/"/>
      <url>/posts/1570400975/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript中-和-的原理"><a href="#JavaScript中-和-的原理" class="headerlink" title="JavaScript中==和===的原理"></a>JavaScript中==和===的原理</h2><h3 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a>运算规则</h3><p>在比较之前，==的两个操作符都会进行强制类型转换，== 和 != 都遵循以下准则:</p><ol><li>如果有一个操作符是布尔值，咋在比较相等性之前会先将其转换为数值，即调用Number()函数.</li><li>如果有一个操作符是字符串，另一个是数值时，在比较相等性之前会先将字符串转换为数组，即调用Number()函数.</li><li>如果有一个操作符是对象类型，另一个是原始类型，则会先将对象转换为原始类型再进行相等性比较，对象转原始类型按照以下流程运行：  <blockquote><p>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数，其逻辑如下：  </p><ol><li>如果有Symbol.toPrimitive()方法，优先调用并返回</li><li>调用valueOf()，如果转换为原始类型，则返回</li><li>调用toString()，如果转换为原始类型，则返回</li><li>如果都没有返回原始类型，会报错</li><li>js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。</li></ol></blockquote></li></ol><p>以上是类型转换时遵循的原则，在转换成基本数据类型以后，会出现两边都是同个类型或不同类型的情况，在进行比较时又遵循以下原则：  </p><ol><li>null和undefined是相等的，这是js规定的，但其实在底层，undefined是派生自null的，所以逻辑等时要返回true.</li><li>如果有个操作数是NaN，则返回false(NaN不与任何操作符逻辑等或全等，包括自身). </li><li>如果两个操作符都是对象，则比较它们是不是同一个对象，是则返回true.</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol><li><p>[] == ![]的结果为什么是true？  </p><blockquote><ol><li>首先<code>[]</code>是数组不是原始类型，先通过<code>valueOf -&gt; toString</code>的顺序转换成<code>&quot;&quot;</code>空字符串。</li><li>js中，对于空数组<code>[]</code>在进行逻辑判断时都会返回true。<code>![]</code>就返回false了。false在逻辑判断时会通过Number函数转换成0。</li><li>运算符左侧是空字符串，右侧是数字0，根据运算准则，会将空字符串通过Number函数转成数字0。</li><li>最后0==0成立，返回true。</li></ol></blockquote></li><li><p>如何让a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3结果为true？  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 设置默认值为0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  value: 0,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 复写valueOf方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  valueOf() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F; 每次自增，让value慢慢增加</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      this.value++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      return this.value;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">console.log(a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3);&#x2F;&#x2F;true</span></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/posts/1376120437/"/>
      <url>/posts/1376120437/</url>
      
        <content type="html"><![CDATA[<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>  React的生命周期从广义上分为三个阶段：挂载、渲染、卸载:</p><ol><li>挂载卸载过程<br>1.1 constructor()<br>1.2 componentWillMount()<br>1.3.componentDidMount()<br>1.4.componentWillUnmount ()  </li><li>更新过程<br>2.1. componentWillReceiveProps (nextProps)<br>2.2.shouldComponentUpdate(nextProps,nextState)<br>2.3.componentWillUpdate (nextProps,nextState)<br>2.4.componentDidUpdate(prevProps,prevState, snapshot)<br>2.5.render()   </li><li>React新增的生命周期(个人补充)<br>3.1. getDerivedStateFromProps(nextProps, prevState)<br>3.2. getSnapshotBeforeUpdate(prevProps, prevState)  </li></ol><h3 id="1-2-为什么对某些生命周期函数称为UNSAFE"><a href="#1-2-为什么对某些生命周期函数称为UNSAFE" class="headerlink" title="1.2 为什么对某些生命周期函数称为UNSAFE"></a>1.2 为什么对某些生命周期函数称为UNSAFE</h3><p>  自从react更新到16.3版本后，以前使用的 componentWillMount、 componentWillReceiveProps、 componentWillUpdate三个生命周期函数都有eslint报警，让我们使用 UNSAFE_前缀的新的生命周期函数，这也是为了提醒开发者，这些生命周期函数是有缺陷的。  </p><ol><li><p>componentWillMount<br>componentWillMount生命周期发生在首次渲染前，如果在此处进行初始化数据或异步获取外部数据，一旦过程中出现异常，错误，会导致页面直接渲染不出来。</p></li><li><p>componentWillReceiveProps<br>compoenntWillReceiveProps是在props发生变化时触发，一般用于props参数更新时同步更新state。但如果在此处调用父组件的某些有调用setState函数，则会让程序陷入死循环，导致崩溃。</p></li><li><p>componentWillUpdate<br>componentWillUpdate和componentDidUpdate这两个生命周期有一定的时间差。componentWillUpdate后经过渲染，计算，再更新Dom元素，最后才调用componentDidUpdate。如果在componentWillUpdate中调用setState，可能会出现多次调用只更新一次的问题。</p></li></ol><h3 id="1-3-getDerivedStateFromProps和getSnapshotBeforeUpdate"><a href="#1-3-getDerivedStateFromProps和getSnapshotBeforeUpdate" class="headerlink" title="1.3 getDerivedStateFromProps和getSnapshotBeforeUpdate"></a>1.3 getDerivedStateFromProps和getSnapshotBeforeUpdate</h3><ul><li>getDerivedStateFromProps<br>getDerivedStateFromProps接受最新的props值和上一个state两个参数，返回一个对象来更新state，或者返回null表示不更新state。但是，<code>getDerivedStateFromProps不能访问this</code>，所以如果要和上一次的props做比较，只能把props值存到state里作为镜像。</li><li>getSnapshotBeforeUpdate<br>getSnapshotBeforeUpdate触发的时机是在最近的更改被提交到DOM前，使得组件可以在更改之前获取到当前值，此函数返回的值会作为componentDidUpdate的第三个参数传入</li></ul><h3 id="什么是PureComponent"><a href="#什么是PureComponent" class="headerlink" title="什么是PureComponent"></a>什么是PureComponent</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用AbortController中断请求</title>
      <link href="/posts/592624706/"/>
      <url>/posts/592624706/</url>
      
        <content type="html"><![CDATA[<h2 id="使用AbortController中断请求"><a href="#使用AbortController中断请求" class="headerlink" title="使用AbortController中断请求"></a>使用AbortController中断请求</h2><p><code>AbortController</code>是DOM规范的一部分，用来中止一个或多个DOM请求。DOM请求可以是Promise或者fetch等。</p><p><strong><em>用法</em></strong></p><p>  使用<code>new AbortController()</code>构造函数创建一个<code>AbortController</code>对象示例，<code>AbortController</code>对象上有个<code>signal</code>属性，可以用来<code>with/abort</code>一个Web请求。使用<code>AbortController.abort()</code>方法中断一个尚未完成Web请求。</p><p><strong><em>示例</em></strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">export default function App() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 创建AbortController对象</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  const controller &#x3D; new AbortController();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 获取signal属性</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  const signal &#x3D; controller.signal;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  const doSomethingAsync &#x3D; (&#123;signal&#125;) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    if (signal.aborted) return Promise.reject(new DOMException(&#39;Aborted&#39;, &#39;AbortError&#39;));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      console.log(&#39;Promise Started&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      const timeout &#x3D; window.setTimeout(resolve, 10000, &#39;Promise Resolved&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">      signal.addEventListener(&#39;abort&#39;, () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        window.clearTimeout(timeout);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        reject(new DOMException(&#39;Aborted&#39;, &#39;AbortError&#39;));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  const getData &#x3D; () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    doSomethingAsync(&#123; signal &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">      .then(result &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">          console.log(result);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">      &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      .catch(err &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        console.log(err);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">          if (err.name &#x3D;&#x3D;&#x3D; &#39;AbortError&#39;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">              console.log(&#39;Promise Aborted&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">          &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">              console.log(&#39;Promise Rejected&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">  const abortReuqest &#x3D; () &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 调用abort方法中断请求</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    controller.abort();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">      &lt;button onClick&#x3D;&#123;getData&#125;&gt;开始请求&lt;&#x2F;button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">      &lt;button onClick&#x3D;&#123;abortReuqest&#125;&gt;中断请求&lt;&#x2F;button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    &lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面的DOMContentLoaded事件</title>
      <link href="/posts/503882416/"/>
      <url>/posts/503882416/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的事件循环</title>
      <link href="/posts/3084422494/"/>
      <url>/posts/3084422494/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript中的事件循环"><a href="#JavaScript中的事件循环" class="headerlink" title="JavaScript中的事件循环"></a>JavaScript中的事件循环</h2><h3 id="为什么会有事件循环"><a href="#为什么会有事件循环" class="headerlink" title="为什么会有事件循环"></a>为什么会有事件循环</h3><p>首先我们知道，<code>JavaScript是一门单线程的非阻塞的脚本语言</code></p><blockquote><ol><li><strong>单线程</strong>: JavaScripts是单线程的，指的是JavaScript引擎中解析和执行JavaScript的线程只有一个（主线程）， 每次只能做一件事情。单线程是必然的，因为如果JavaScript是多线程，那么当两个线程同时对一个dom进行操作，例如一个向其添加事件监听，而另一个删除了该dom，这个是矛盾的。</li><li><strong>非阻塞</strong>: 当我们的JavaScript代码运行一个异步任务的时候（像ajax等），主线程会挂起这个任务，然后异步任务返回结果的时候再根据特定的结果去执行相应的回调函数。</li></ol></blockquote><p>那么如何做到非阻塞呢？这就需要——<code>事件循环(Event Loop)</code></p><h3 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h3><p>下面这张图可以帮助您了解JavaScript的调用堆栈/事件循环/回调队列如何相互影响</p><p><img alt="Event Loop" data-src="/posts/3084422494/event_loop.png" class="lazyload"></p><p>当JavaScript代码执行的时候回将不同的变量存于内存中的不同位置：堆(heap)或者栈(stack)中来加以区分。其中，堆里存放的是一些对象，而栈中则存放的是一些基础类型变量以及对象的指针。</p><p><strong>执行栈</strong></p><p>当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方，这个地方就叫<code>执行栈</code>。</p><p>比如下面是一段同步执行的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function a() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    b();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;a&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">function b() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;b&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">a();</span></pre></td></tr></table></figure><p>下图演示的是代码的执行过程：<br><img alt="Sync " data-src="/posts/3084422494/sync.png" class="lazyload"></p><ol><li>执行函数a先入栈  </li><li>函数a中先执行函数b，b入栈</li><li>执行函数b，console.log(b)入栈</li><li>输出b，console.log(b)出栈</li><li>函数b执行完成，b出栈</li><li>console.log(‘a’)入栈，执行。输出a，出栈 </li><li>函数a执行完成，a出栈</li></ol><p>同步代码的执行过程比较简单，那异步的呢？</p><p>JavsScript引擎遇到一个异步事件后并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，JavaScript会将这个事件加入到与当前执行栈不同的另一个队列，称为<strong>事件队列</strong></p><p>被放入事件队列之后不会立即执行起回调，而是等待当前执行栈中的所有任务都执行完毕，主线程空闲状态，主线程会去查找事件队列中是否有任务，如果有，则取出排在第一位的事件，并把这个事件对应的回调放到执行栈中，然后执行其他的同步代码。</p><p>看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$.on(&#39;button&#39;, &#39;click&#39;, function onClick() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    setTimeout(function timer() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        console.log(&#39;You clicked the button!&#39;);    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;, 2000);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hi!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">setTimeout(function timeout() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    console.log(&quot;Click the button!&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;, 5000);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">console.log(&quot;Welcome to loupe.&quot;);</span></pre></td></tr></table></figure><p>下图演示的是代码的执行过程：<br><img alt="Sync " data-src="/posts/3084422494/async.gif" class="lazyload"></p><p>来分析下执行过程：</p><ol><li>首先是，注册了点击事件，异步执行，这个时候会把它放到Web api中</li><li>console.log(“Hi!”)入栈，直接执行，输出Hi</li><li>执行setTimeout， 异步执行，先挂载起来</li><li>执行console.log(“Welcome to loupe.”)，输出Welcome to loupe.</li><li>5秒钟后，setTimeout执行回调，将回调放入事件队列中，一旦主线程空闲，则取出运行。</li><li>此时点击按钮，触发点击事件，将点击事件的回调放入到事件队列中，一旦主线程空闲，则取出运行</li><li>运行点击事件中的setTimeout</li><li>2秒后，setTimeout执行回调，将回调放入事件队列中，一旦主线程空闲，则取出运行。</li></ol><h2 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h2><h3 id="微任务——Micro-Task"><a href="#微任务——Micro-Task" class="headerlink" title="微任务——Micro-Task"></a>微任务——Micro-Task</h3><p>常见的有<code>process.nextTick</code>、<code>new Promise().then(callback)</code>、 <code>MutationObserver</code>,它们的优先级是<code>process.nextTick &gt; Promise = MutationObserver</code></p><h3 id="宏任务——Micro-Task"><a href="#宏任务——Micro-Task" class="headerlink" title="宏任务——Micro-Task"></a>宏任务——Micro-Task</h3><p>常见的有<code>setTimeout</code>、 <code>setInterval</code>、 <code>主代码块</code>、<code>I/O操作</code>、 <code>UI交互事件</code>、 <code>postMessage</code>等。优先级是<code>主代码块 &gt; setImmediate &gt; MessageChannel &gt; setTimeout / setInterval</code>，大部分浏览器会把DOM事件回调优先处理 因为要提升用户体验 给用户反馈，其次是network IO操作的回调，再然后是UIrender，之后的顺序就难以捉摸了，其实不同浏览器的表现也不太一样，这里不做过多讨论。</p><h3 id="事件循环的执行顺序"><a href="#事件循环的执行顺序" class="headerlink" title="事件循环的执行顺序"></a>事件循环的执行顺序</h3><p>异步任务的返回结果会被放到一个事件队列中，根据上面提到的异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。</p><p><code>Event Loop</code>的循环过程如下：</p><ol><li>执行一个宏任务(一般是主代码块),如果没有可选的宏任务，则直接处理微任务</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>执行过程中如果遇到宏任务，就将它添加到宏任务的任务队列中</li><li>执行一个宏任务完成之后，就需要检测微任务队列有没有需要执行的任务，有的话，全部执行，没有的话，进行下一步</li><li>检查渲染，然后<code>GUI</code>线程接管渲染，进行浏览器渲染</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（…循环上面的步骤）</li></ol><p>总结就是：<code>执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，等所有微任务执行完毕后，再回到宏任务中进行下一轮循环</code></p><p>看下面这个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">console.log(&#39;start&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;setTimeout&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;, 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(function() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;promise1&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;).then(function() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;promise2&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">console.log(&#39;end&#39;)</span></pre></td></tr></table></figure><p>分析一下流程：</p><ol><li>执行console.log(‘start’), 输出start</li><li>执行setTimeout，压入宏任务队列</li><li>执行promise.then，回调压入微任务队列</li><li>执行console.log(‘end’)，输出end</li><li>主流程属于宏任务，执行完成后接下来要执行微任务队列中的任务了，也就是执行promise.then,输出promise1</li><li>此时又promise的第二个回调函数，压入微任务队列。由于event loop会把当前的微任务队列一直执行完，所以继续执行promise的第二个回调函数，输出promise2</li><li>这时微任务队列已经为空，接下来主线程会进行一些UI渲染工作（非一定要做），然后开始下一轮event loop，执行宏任务队列的任务。</li><li>此时宏任务队列中仅剩下setTimeout的回调，输出setTimeout</li></ol><p>故最后的输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">start</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">end</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">promise then 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">promise then 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">setTimout</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrtipt标签的defer和async</title>
      <link href="/posts/1750268648/"/>
      <url>/posts/1750268648/</url>
      
        <content type="html"><![CDATA[<h2 id="Scrtipt标签的defer和async"><a href="#Scrtipt标签的defer和async" class="headerlink" title="Scrtipt标签的defer和async"></a>Scrtipt标签的defer和async</h2><p>defer和async是script标签的两个属性，用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。为什么设计这两个属性呢？</p><p><strong><em>为什么给要script标签添加 async 或 defer？</em></strong></p><p>首先需要了解一下页面的加载和渲染过程：</p><ol><li>浏览器通过http协议请求服务器，获取HTML文档并开始从上到下解析，构建DOM;</li><li>在构建DOM过程中，如果遇到外联的样式声明和脚本声明，则暂停文档解析，创建新的网络连接，并开始下载样式文件和脚本文件;</li><li>样式文件下载完成后，构建CSSDOM;脚本文件下载完成后，解析并执行，然后继续解析文档并构建DOM;</li><li>完成文档解析后，将DOM和CSSDOM进行关联和映射，最后将视图渲染到浏览器窗口。在这个过程中，脚本文件的下载和执行是与文档解析同步进行的，也就是说，<code>脚本的解析和执行会阻塞文档的解析</code>，如果控制不好，在用户体验上就会造成一定程度的影响。</li></ol><p>为了避免js和css会阻塞文档解析，比较流行的做法是<code>样式放顶部，脚本放底部</code>，但是这种做法并没有从根本上解决问题。实际上，并不是所有的脚本对用户体验都是同等的重要，能否有一种解决方法，可以尽可能的异步加载那些不那么重要的脚本。</p><p><strong><em>defer和async的作用</em></strong></p><p><code>defer</code>和<code>async</code>属性，就是用来告诉浏览器哪些脚本是需要异步加载的。这两个属性都告诉浏览器，在加载脚本的同时继续解析HTML，并在脚本加载完之后再执行。这样脚本下载就不会阻塞DOM构建和页面渲染了。结果就是，用户可以在所有的脚本加载完成之前就能看到页面了。</p><p><strong><em>defer和async的区别</em></strong> </p><p>两者的区别在于<code>执行时间不同</code>。</p><ol><li><p>默认引用script： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;x.min.js&quot;&gt;&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure><p>当浏览器遇到script标签时，<code>文档的解析将会停止，然后立即下载脚本并执行，脚本执行完毕后在解析文档</code>。</p></li><li><p>async模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;x.min.js&quot; async&#x3D;&quot;async&quot;&gt;&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure><p>当浏览器遇到script标签时，<code>文档解析不会停止而是会继续往下解析，同时异步下载脚本。脚本下载完成后会立即执行脚本，此时会中断文档的解析过程，直到脚本执行完毕</code>。</p></li><li><p>defer模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;x.min.js&quot; defer&#x3D;&quot;defer&quot;&gt;&lt;&#x2F;script&gt;</span></pre></td></tr></table></figure><p>当浏览器遇到script标签时，<code>文档解析不会停止而是会继续往下解析，同时异步下载脚本。等到文档解析完毕后，脚本才会执行</code>。</p></li></ol><blockquote><p>所以async和defer的区别就是，async是脚本下载完毕后会立即执行，defer是等到文档解析完成后再执行脚本。</p></blockquote><p><strong><em>总结</em></strong></p><ul><li><p>相同 </p><ol><li>都是异步的加载脚本文件，加载时不会阻塞DOM渲染</li><li>都是在页面load之前执行</li><li>对于内嵌脚本无效。即缺少src属性。</li></ol></li><li><p>不同   </p><ol><li>async属性的脚本无法确定是在<code>DOMContentLoaded</code>之前还是之后执行。defer属性的脚本一定是在<code>DOMContentLoaded</code>之前执行</li><li>async属性的脚本并不一定按照顺序执行（先加载完成的先执行）。defer属性的脚本会按照顺序执行</li></ol></li></ul><p><strong><em>其他</em></strong></p><p>  <strong>css阻塞有什么解决办法？</strong></p><blockquote><p>css的加载不会导致HTML解析和渲染的阻塞，但会影响到js脚本的执行。因为js脚本不仅可以读取修改dom，也可以读取修改cssom。故在js脚本执行前，浏览器必须保证css文件完全加载完毕，即cssom树完全构建好。这就导致了js脚本执行的延迟，这是css的加载阻塞js脚本执行的根本原因。</p></blockquote><p>  对此，这里有一些解决办法：</p><ul><li>在引入顺序上，css资源的引入要由于js资源的引入。</li><li>对css进行精简并尽快提供</li><li>可以用媒体类型（会加载不会阻塞）</li><li>用媒体查询（会记载，只有在符合的设备上才会进行阻塞）</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React路由设置createBrowserHistory之后页面刷新报错问题解决</title>
      <link href="/posts/2425023234/"/>
      <url>/posts/2425023234/</url>
      
        <content type="html"><![CDATA[<h2 id="React路由设置createBrowserHistory之后页面刷新报错问题解决"><a href="#React路由设置createBrowserHistory之后页面刷新报错问题解决" class="headerlink" title="React路由设置createBrowserHistory之后页面刷新报错问题解决"></a>React路由设置createBrowserHistory之后页面刷新报错问题解决</h2><p><strong><em>问题</em></strong></p><p>使用browserHistory时页面刷新时控制台会报错：<code>Uncaught SyntaxError: Unexpected token &lt;</code></p><p><strong><em>解决办法</em></strong></p><p>在index.html中修改资源引入路径，使用绝对路径进行引入</p><p>例如：</p><p><img alt="修改前" data-src="/posts/2425023234/before.png" class="lazyload"></p><p>使用绝对路径引入:</p><p><img alt="修改后" data-src="/posts/2425023234/after.png" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写防抖、节流</title>
      <link href="/posts/2442577863/"/>
      <url>/posts/2442577863/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>npm 依赖包版本号~和^的区别</title>
      <link href="/posts/2795930560/"/>
      <url>/posts/2795930560/</url>
      
        <content type="html"><![CDATA[<h2 id="npm-依赖包版本号-和-的区别"><a href="#npm-依赖包版本号-和-的区别" class="headerlink" title="npm 依赖包版本号~和^的区别"></a>npm 依赖包版本号~和^的区别</h2><ul><li><code>~</code>会匹配最近的小版本依赖包，比如<code>~1.2.3</code>会匹配所有1.2.x版本，但是不包括1.3.0</li><li><code>^</code>会匹配最新的大版本依赖包，比如<code>^1.2.3</code>会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0</li><li><code>*</code>会安装最新版本的依赖包</li></ul><p>那么该如何选择呢？当然你可以指定特定的版本号，直接写1.2.3，前面什么前缀都没有，这样固然没问题，但是如果依赖包发布新版本修复了一些小bug，那么需要手动修改package.json文件；<code>~</code>和<code>^</code>则可以解决这个问题。<br>但是需要注意<code>^</code>版本更新可能比较大，会造成项目代码错误，所以建议使用<code>~</code>来标记版本号，这样可以保证项目不会出现大的问题，也能保证包中的小bug可以得到修复。<br>版本号写<code>*</code>，这意味着安装最新版本的依赖包，但缺点同上，可能会造成版本不兼容，慎用！</p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MessageChannel消息通道</title>
      <link href="/posts/2399429143/"/>
      <url>/posts/2399429143/</url>
      
        <content type="html"><![CDATA[<h2 id="MessageChannel消息通道"><a href="#MessageChannel消息通道" class="headerlink" title="MessageChannel消息通道"></a>MessageChannel消息通道</h2><p>在浏览器环境中，常见的宏任务有 <code>setTimeout/setInterval</code>、<code>MessageChannel</code>、<code>postMessage</code> 和 <code>setImmediate</code>等。常见的微任务有 <code>Promise.then</code> 和 <code>MutationObserver</code>等。Vue中对于宏任务的实现，会优先监测是否支持原生<code>setImmediate</code>，这是一个高版本IE和Edge才支持的特性，不支持的话再去检测是否支持原生的<code>MessageChannel</code>，如果也不支持的话会降级为setTimeout 0。</p><h3 id="MessageChannel"><a href="#MessageChannel" class="headerlink" title="MessageChannel"></a>MessageChannel</h3><p><code>MessageChannel</code>允许我们创建一个新的消息通道，并通过它的两个<code>MessagePort</code>属性发送数据。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个管道</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">var channel &#x3D; new MessageChannel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取实例的两个端口</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">var port1 &#x3D; channel.port1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">var port2 &#x3D; channel.port2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 给每个端口绑定onmessage事件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">port1.onmessage &#x3D; function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    console.log(&quot;port1收到来自port2的数据：&quot; + event.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">port2.onmessage &#x3D; function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    console.log(&quot;port2收到来自port1的数据：&quot; + event.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个端口只要绑定了onmessage事件，就可以接受从另一个端口发出的消息</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">port1.postMessage(&quot;发送给port2&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">port2.postMessage(&quot;发送给port1&quot;);</span></pre></td></tr></table></figure><p>简单来说，<code>MessageChannel</code>创建了一个通信的管道，管道有两个端口，每个端口都是只读的。这两个端口都可以通过postMessage发送消息。当一个端口绑定了onmessage事件时，就可以接受从另一个端口发出的消息。</p><p>消息通道就像是一条左右贯通的管道，左右两个端口就是 port1 和 port2</p><p>这两个端口可以相互发送消息，port1 发送的消息可以在 port2 接收到，反之亦然</p><p><img alt="MessageChannel" data-src="/posts/2399429143/MessageChannel.png" class="lazyload"></p><h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><p><strong>深拷贝</strong></p><p>大部分需要深拷贝的场景，都可以使用以下代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">JSON.parse(JSON.stringify(object))</span></pre></td></tr></table></figure><p>但这种办法会忽略掉<code>undefined</code>、<code>null</code>、<code>symbol</code>和<code>循环引用的对象</code>，而通过<code>postMessage</code>方法传输的<code>message</code>是深拷贝的，可以拷贝undefined和循环引用的对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function deepClone(msg) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  var ms &#x3D; new MessageChannel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; onmessage是异步的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    ms.port1.onmessage &#x3D; function(e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      resolve(e.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    ms.port2.postMessage(msg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  var obj &#x3D; &#123;name: &#39;zs&#39;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  var obj1 &#x3D; await deepClone(obj);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  obj.age &#x3D; 18;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  console.log(obj); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  console.log(obj1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">test();</span></pre></td></tr></table></figure><p>但<code>MessageChannel</code>对于<code>Symbol</code>和<code>function</code>依然束手无策</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Worker介绍</title>
      <link href="/posts/3671681857/"/>
      <url>/posts/3671681857/</url>
      
        <content type="html"><![CDATA[<h2 id="Web-Worker介绍"><a href="#Web-Worker介绍" class="headerlink" title="Web Worker介绍"></a>Web Worker介绍</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JavaScript采用的是单线程非阻塞模型，所有任务只能在一个线程上跑，一次只能做一件事。前面的任务没做完，后面的任务只能等着，随着多核CPU的出现，单线程带来的不便，无法充分发挥计算机的计算能力。</p><p><code>Web Worker</code>的出现，就是为JavaScript创造了多线程环境，允许主线程创建Worker线程，将一些任务分配给后者运行。在主线程运行的时候，Worker线程在后台运行，两者互不干扰，等到Worker线程计算完成，再把结果返回给主线程，这样的好处是，一些计算密集型或者高延迟的任务可以交给Worker线程来承担，主线程会很流畅，不会被阻塞或者拖慢。</p><p>但是Worker线程一旦新建成功，就会始终运行，不会被主线程的活动（比如用户点击按钮，提交表单）打断。这样有利于随时响应主线程的通信，但是这样也造成了Worker比较耗费资源，不应该过度使用,而且一旦使用完毕，应当立即关闭。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>Web Worker有以下几个使用注意点：</p><ul><li><p>同源限制</p><p>分配给Worker线程运行的脚本文件，必须与主线程的脚本文件同源</p></li><li><p>DOM限制</p><p>Worker线程所在的全局对象，与主线程不一样，无法读取主线程所在页面的DOM对象，也无法使用document, window, parent这些对象。但是Worker线程可以使用 navigator 和 location 对象</p></li><li><p>通信联系</p><p>Worker线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p></li><li><p>脚本限制</p><p>Worker线程不能使用alert和confirm方法，但可以使用XMLHttpRequest对象发出ajax请求</p></li><li><p>文件限制</p><p>Worker线程无法读取本地文件，即不能打开本机的文件系统（file://)，它所加载的脚本必须来自网络。</p></li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li><p>主线程</p><p>主线程采用new命令，调用Worker()构造函数，新建一个Worker线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var worker &#x3D; new Worker(&#39;work.js&#39;);</span></pre></td></tr></table></figure><p>Worker()构造函数接受一个脚本文件作为参数，该文件就是Worker线程所要执行的任务，如果读取脚本文件失败，Worker会默默的失败。</p><p>然后主线程调用Worker.postMessage()方法，向Worker发消息，方法的参数就是发送的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">worker.postMessage(&#39;hello world&#39;);</span></pre></td></tr></table></figure><p>接着主线程通过worker.onmessage指定监听函数，接受子线程发来的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">worker.onmessage &#x3D; function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;接收到子线程发来的消息：&#39; + event.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><p>Worker完成任务以后，主线程就可以把它关掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">worker.terminate();</span></pre></td></tr></table></figure></li><li><p>worker线程<br>worker线程内部需要一个监听函数，监听message事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">self.addEventListener(&#39;message&#39;, function(e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  self.postMessage(e.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>上面代码中，self代表子线程自身，即子线程的全局对象，等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">this.addEventListener(&#39;message&#39;, function(e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  self.postMessage(e.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 或</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">addEventListener(&#39;message&#39;, function(e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  self.postMessage(e.data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>另外，</p><ol><li>worker使用完毕，为了节省系统资源，必须关闭。主线程使用<code>worker.terminate()</code>关闭worker线程, <code>self.close()</code>用于在Worker内部关闭自身。</li><li>Worker内部如果想加载其他脚本，有一个专门的方法<code>importScripts()</code>, 该方法可以同时加载多个脚本。: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">importScripts(&#39;script1.js&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;);</span></pre></td></tr></table></figure></li><li>主线程可以监听Worker是否发生错误，如果发生错误，Worker会触发主线程的error事件。worker内部也可以监听error事件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">worker.onerror(function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 或者</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">worker.addEventListener(&#39;error&#39;, function(event) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><h3 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h3></li></ol><p>主线程于worker线程之间的通信内容，可以是文本，也可以是对象。需要注意的是，<code>这种通信是拷贝，是传值而不是传址</code>，worker对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行后的字符串传给worker，后者再将其还原。</p><p>但是这种拷贝的方式发送二进制数据会造成性能问题，比如主线程向worker发生一个500MB文件，默认情况下浏览器会生成一个原文件的拷贝，为了解决这个问题，JavaScript允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫<code>transferable objects</code>，这使得主线程可以快速把数据交给Worker，对应影像处理、声音处理、3D运算等就非常方便，不会产生性能负担。 </p><p>如果要直接转移数据的控制权，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; transferable objects 格式</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">worker.postMessage(arrayBuffer, [arrayBuffer]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 例子</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">var ab &#x3D; new ArrayBuffer(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">worker.postMessage(ab, [ab])</span></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setImmediate函数</title>
      <link href="/posts/3084422494/"/>
      <url>/posts/3084422494/</url>
      
        <content type="html"><![CDATA[<h2 id="setImmediate函数"><a href="#setImmediate函数" class="headerlink" title="setImmediate函数"></a>setImmediate函数</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>setImmediate函数用来把一些需要长时间运行的操作放到一个回调函数中，并在浏览器完成其他操作后立即执行。使用此方法可以替代setTimeout(fn, 0)方法。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var immediateID &#x3D; setImmediate（func，[ param1，param2，...]）;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">var immediateID &#x3D; setImmediate（func）;</span></pre></td></tr></table></figure><ul><li>immediateID 是这次setImmediate方法设置的唯一ID,可以作为 window.clearImmediate 的参数.</li><li>func 是将要执行的回调函数，参数param1 param2 ..都会直接传给函数func</li><li>window.clearImmediate 方法可以用来取消通过setImmediate设置的将要执行的语句, 就像 window.clearTimeout 对应于 window.setTimeout一样.</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>此函数是非标准的，能存在很大的不兼容性，目前仅IE和Node.js 0.10+的最新版本实现。Firefox和谷歌不支持此函数！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的 MutationEvents 和 MutationObserver</title>
      <link href="/posts/3084422494/"/>
      <url>/posts/3084422494/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript中的-MutationEvents-和-MutationObserver"><a href="#JavaScript中的-MutationEvents-和-MutationObserver" class="headerlink" title="JavaScript中的 MutationEvents 和 MutationObserver"></a>JavaScript中的 MutationEvents 和 MutationObserver</h2><h3 id="MutationEvents"><a href="#MutationEvents" class="headerlink" title="MutationEvents"></a>MutationEvents</h3><p>MutationEvents是一系列dom树的变动的监听事件，总共有9种事件： </p><ul><li>DOMAttrModified</li><li>DOMAttributeNameChanged</li><li>DOMCharacterDataModified</li><li>DOMElementNameChanged</li><li>DOMNodeInserted</li><li>DOMNodeInsertedIntoDocument</li><li>DOMNodeRemoved</li><li>DOMNodeRemovedFromDocument</li><li>DOMSubtreeModified</li></ul><p><strong>用法</strong></p><p>以下是给document注册DOMNodeInserted事件的示例，当dom树结构发生变动时触发回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;DOMNodeInserted&quot;, function () &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; do something</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p><strong>注意</strong><br>MutationEvents 的所有事件都被设计成<code>不可取消</code>，意味着一旦注册之后不能再removeEventListener取消监听了。MutationEvents 事件机制是同步的，也就是说每次DOM修改就会触发，修改几次就触发几次，影响性能。</p><h3 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h3><p>MutationObserver, dom树的变动观察者，是用来<code>监听DOM树的更改</code>，它是作为旧的MutationEvents的替代品，它的出现就是为了解决MutationEvents的问题。</p><p>MutationObserver 是个构造器，接受一个函数作为参数，这个函数会在节点变化时回调，同时返回两个参数，mutations： 节点变化记录列表， observer： MutationObserver对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var observer &#x3D; new MutationObserver(function (mutations, observer) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure><p>MutationObserver有三个方法：</p><ul><li>observe: 设置观察目标<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mutationObserver.observe(target[, options])</span></pre></td></tr></table></figure></li><li>disconnect: 阻止观察者观察任何改变</li><li>takeRecords: 清空记录队列并返回里面的内容</li></ul><p><strong>用法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 选择需要观察变动的节点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">const targetNode &#x3D; document.getElementById(&#39;some-id&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 观察器的配置（需要观察什么变动）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const config &#x3D; &#123; attributes: true, childList: true, subtree: true &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当观察到变动时执行的回调函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">const callback &#x3D; function(mutationsList, observer) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; Use traditional &#39;for loops&#39; for IE 11</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    for(let mutation of mutationsList) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        if (mutation.type &#x3D;&#x3D;&#x3D; &#39;childList&#39;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            console.log(&#39;A child node has been added or removed.&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        else if (mutation.type &#x3D;&#x3D;&#x3D; &#39;attributes&#39;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            console.log(&#39;The &#39; + mutation.attributeName + &#39; attribute was modified.&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个观察器实例并传入回调函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">const observer &#x3D; new MutationObserver(callback);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 以上述配置开始观察目标节点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">observer.observe(targetNode, config);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 之后，可停止观察</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">observer.disconnect();</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object.freeze函数</title>
      <link href="/posts/3106097719/"/>
      <url>/posts/3106097719/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-freeze函数"><a href="#Object-freeze函数" class="headerlink" title="Object.freeze函数"></a>Object.freeze函数</h2><p>Object.freeze(),冻结函数，该方法用于冻结一个对象。<code>一个被冻结的对象将不能修改属性，删除已有属性或添加新的属性</code>。此外，<code>冻结一个对象之后，该对象的原型也不能被修改</code>。该方法的返回值为传入的对象。</p><p>看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; age: 18 &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Object.freeze(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">a.age &#x3D; 20;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">a.name &#x3D; &#39;zs&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">delete a.age; &#x2F;&#x2F; false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr></table></figure><p>同时冻结的对象的原型也不能被修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; age: 18 &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Object.freeze(a); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">var b &#x3D; a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">b.age &#x3D; 20;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">console.log(b); &#x2F;&#x2F; &#123;age: 18&#125;</span></pre></td></tr></table></figure><p>但是，Object.freeze()只是<code>浅冻结</code>，被冻结的对象并不总是不可变的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; name: &#123; firstName: &#39;zhang&#39; &#125; &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Object.freeze(a);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">a.name.firstName &#x3D; &#39;wang&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">console.log(a); &#x2F;&#x2F; &#123; name: &#123; firstName: &quot;wang&quot; &#125; &#125;</span></pre></td></tr></table></figure><p>最后，需要注意的是，<code>只要freeze之后，就不能解除了</code>，所以使用这个API需要谨慎</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack之tree shaking</title>
      <link href="/posts/42071/"/>
      <url>/posts/42071/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack之tree-shaking"><a href="#webpack之tree-shaking" class="headerlink" title="webpack之tree shaking"></a>webpack之tree shaking</h2><p>webpack从2.0开始引入tree shaking概念。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>先了解下webpack中几个相关概念：</p><ul><li><p>AST<br>AST对JS代码进行语法分析后得出的语法树（Abstract Syntax Tree）。AST语法树可以把一段JS代码的每一个语句转化成语法树中的一个节点。</p></li><li><p>DCE<br>Dead Code Elimination,在保持代码运行结果不变的前提下，去除无用的代码。这样的好处是：</p><ul><li>优化代码</li><li>减小程序体积</li><li>减少程序执行时间</li></ul><p>其中Dead Code指的是：</p><ul><li>程序中不会执行的代码（如不可能进入的分支，return之后的代码等）</li><li>写入变量之后不再读取的代码</li></ul></li></ul><p>tree shaking是 DCE 的一种方式，它可以在打包时忽略没有用到代码。</p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>首先需要知道webpack的运行机制：</p><ol><li><p>先使用babel-loader处理js文件</p><p> babel的配置文件中有一个preset配置项：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  preset: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    [&#39;env&#39;, &#123; &#39;module&#39;: false &#125;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p> 其中presets里的env有个module的配置项，设置为false，这是指示babel如何去处理impory和export等关键字，默认以require形式，设置为false则babel就不会把import，export转成require形式了，这也为webpack的tree shaking创造了条件。</p></li><li><p>然后webpack进行tree-shaking识别和记录，打包处理</p><p> <code>webpack在认定某块代码无用后，会再处理过程中写下一段注释。uplifyjs会根据这点注释去进行删除代码。</code></p><p> webpack负责对代码进行标记，把import&amp;export分为3类：</p><ul><li>所有import标记为 /* harmony import */ </li><li>被使用过的export标记为 /* harmony export([type]) */, 其中type和webpack有关，可能是binding，immutable等</li><li>没被使用过的import标记为 /* unused harmony export [FunctionName] */, 其中FunctionName即export的方法名称</li></ul></li><li><p>最后由uglifyjs根据webpack标识删除多余代码，进行代码压缩</p></li></ol><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React.memo和useMemo的使用</title>
      <link href="/posts/56913/"/>
      <url>/posts/56913/</url>
      
        <content type="html"><![CDATA[<h2 id="React-memo和useMemo的使用"><a href="#React-memo和useMemo的使用" class="headerlink" title="React.memo和useMemo的使用"></a>React.memo和useMemo的使用</h2><p>在React的class Component时代，为了性能优化我们经常使用<code>pureComponent + shouldComponentUpdate</code>对组件进行深层次的控制。</p><p>到了Funciton Component时代，React也提供了<code>memo</code>和<code>useMemo</code>，以达到<code>pureComponent + shouldComponentUpdate</code>同样效果。</p><h3 id="先看个例子："><a href="#先看个例子：" class="headerlink" title="先看个例子："></a>先看个例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, memo, useMemo &#125; from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">import &#123; Input &#125; from &#39;antd&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">export default class TestMemo extends Component &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  state &#x3D; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    firstName: &#39;x&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    lastName: &#39;f&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  handleChange(key, value) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    this.setState(&#123; [key]: value &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;render&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    const &#123; firstName, lastName &#125; &#x3D; this.state;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      &lt;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &lt;Input label&#x3D;&#39;姓&#39; value&#x3D;&#123;firstName&#125; onChange&#x3D;&#123;e &#x3D;&gt; this.handleChange(&#39;firstName&#39;, e.target.value)&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &lt;Input label&#x3D;&#39;名&#39; value&#x3D;&#123;lastName&#125; onChange&#x3D;&#123;e &#x3D;&gt; this.handleChange(&#39;lastName&#39;, e.target.value)&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &lt;FristName name&#x3D;&#123;firstName&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &lt;LastName name&#x3D;&#123;lastName&#125; &#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      &lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">function FristName(&#123;name&#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render firstName&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">function LastName(&#123;name&#125;) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render lastName&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>仔细分析上面的例子，不难发现，每次在父组件的两个Input输入框任意一个中输入值，两个子组件<code>FristName</code>和<code>LastName</code>都会跟着渲染，即使跟子组件并不相关的props更新了，也渲染了一遍。<code>理论上，父组件每次变化一个 state 都通过 props 传递给了子组件，那子组件就会重新执行渲染。（无论子组件有没有真正用到这个 props）</code>，这无疑是浪费的渲染。</p><h3 id="使用memo"><a href="#使用memo" class="headerlink" title="使用memo"></a>使用memo</h3><p>下面我们使用memo对<code>FirstName</code>组件进行改造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import &#123; memo &#125; from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">const propsAreEqual &#x3D; function(prevProps, nextProps) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return prevProps.name &#x3D;&#x3D;&#x3D; nextProps;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const FristName &#x3D; memo((&#123;name&#125;) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render firstName&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;, propsAreEqual);</span></pre></td></tr></table></figure><p>使用了memo改造之后，我们会发现，当改变firstName后，<code>FirstName</code>组件会跟着渲染，而当改变lastName后，在控制台里可以看到<code>render firstName</code>并没有打印，说明<code>FirstName</code>组件并没有渲染，达到了性能优化的目的。</p><h3 id="使用useMemo"><a href="#使用useMemo" class="headerlink" title="使用useMemo"></a>使用useMemo</h3><p>看上面说那个memo的例子，我们发现React.memo是需要包裹整个组件的，并且需要手动写一个方法比较那些具体的props不相同才进行re-render。</p><p>而在某些场景下，我们只是希望component的某些部分不要进行re-render，而不是整个component编剧要re-render，也就是需要局部pure的功能。</p><p><code>useMemo</code>是React自带的hooks API，基本用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import &#123; useMemo &#125; from &#39;react&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">const memoizedValue &#x3D; useMemo(memoizedFunction(), [memoizedParams]);</span></pre></td></tr></table></figure><p>useMemo()返回的是一个memoized值，只有当依赖项memoizedParams发生改变，才会重新调用memoizedFunction函数计算生成新的memoizedValue。memoizedParams不变时不会触发memoizedFunction函数。</p><p>需要注意的是：<code>useMemo是在render期间执行的，所以不能进行一些副作用操作，比如网络请求等。</code></p><p>如果没有提供依赖项即memoizedParams，则每次都会调用memoizedFunction函数计算memoizedValue。</p><p>回到我们的例子，我们希望只有当lastName发生改变时，才会去重新渲染LastName组件，即用useMemo包裹return部分渲染的逻辑，下面是使用useMemo改造后的LastName组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function FristName(&#123;name&#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  console.log(&#39;render firstName out useMemo&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  return useMemo(() &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    console.log(&#39;render firstName in useMemo&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    return (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;, [name]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>再次运行时，我们会发现，<code>render firstName out useMemo</code>一直会打印，当我们没有改变firstName时，在useMemo函数中的这句<code>render firstName in useMemo</code>并不会打印，只有改变了firstName的值时，才会打印。这就是useMemo<code>局部pure</code>的体现了。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Hooks之useCallback</title>
      <link href="/posts/6797/"/>
      <url>/posts/6797/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Hooks之useCallback"><a href="#React-Hooks之useCallback" class="headerlink" title="React Hooks之useCallback"></a>React Hooks之useCallback</h2><p>useCallback</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>img标签的alt和title</title>
      <link href="/posts/8189/"/>
      <url>/posts/8189/</url>
      
        <content type="html"><![CDATA[<h2 id="img标签的alt和title属性"><a href="#img标签的alt和title属性" class="headerlink" title="img标签的alt和title属性"></a>img标签的alt和title属性</h2><p>在html的img标签中，有alt和title两个重要的属性。</p><h3 id="alt属性："><a href="#alt属性：" class="headerlink" title="alt属性："></a>alt属性：</h3><ul><li><p>如果图像没有下载或者加载失败，会用文字来代替图像显示。</p><p>  这一作用是为了给加载不出网页图片的用户提供图片信息，方便用户浏览网页，也方便维护网页。</p></li><li><p>搜索引擎可以通过这个属性的文字来抓取图片</p></li></ul><h3 id="title属性："><a href="#title属性：" class="headerlink" title="title属性："></a>title属性：</h3><ul><li>当网页上的图片被加载完成后，鼠标移动到上面去，会显示这个图片指定的属性文字，以对图片信息进行补充性说明。</li></ul>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to Panda-Wind&#39;s Blog</title>
      <link href="/posts/20593/"/>
      <url>/posts/20593/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://panda-wind.github.io/">Panda-Wind</a>! I will share some interesting things with you here.</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github Page 搭建个人博客（二）发布文章和url处理</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<p>前面我们已经搭建好了我们的博客网站，现在我们来发布新的文章吧！</p><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>新建文章，输入以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo new &#39;文章标题&#39;</span></pre></td></tr></table></figure><p>执行完成后，可以在根目录下/source</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github Page 搭建个人博客（一）安装</title>
      <link href="/posts/undefined/"/>
      <url>/posts/undefined/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建个人博客的方式有很多种，大多数都需要从各种网上代理商上买域名和服务器部署自己的博客系统。本文介绍的是使用 <code>Hexo</code> + <code>Github Page</code>来搭建，这是一种搭建速度最快，完全免费开源，不需要购买任何服务器资源即可运行的方式，而且有 many many 种博客主题供你选择。下面先简单介绍下<code>Hexo</code> 和 <code>Github Page</code>：</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Hexo</code> 是基于Node.js驱动的一款静态博客框架，除了官方提供的很多种主题，github上也有很多开发者分享的开源的主题，都可供使用者自由选择，而且切换主题也相当简单方便。<code>Github Page</code> 是 Github 提供的 一种静态网页托管服务，可以用来托管博客等静态网页资源，关键是免费的！结合使用<code>Hexo</code> + <code>Github Page</code> 可以帮助我们快速搭建个人博客。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>， <code>Hexo</code> 是基于Node.js的，所以需要准备Node环境。</li><li>创建<a href="https://github.com/" target="_blank" rel="noopener">github</a> 账号</li><li>安装<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>，将本地项目打包后生成的静态资源文件上传到github上进行托管。</li></ol><h2 id="Github上创建个人仓库"><a href="#Github上创建个人仓库" class="headerlink" title="Github上创建个人仓库"></a>Github上创建个人仓库</h2><p>首先创建个人仓库，用来存放博客所需要的文件资源：</p><p><img alt="github仓库名" data-src="/posts/undefined/hexo_1.jpg" class="lazyload"></p><p>这时候我们的博客站点<code>http://用户名.github.io</code>就建好了！当然由于是个空项目，访问是空白的。下面我们将使用hexo来创建一个项目来部署我们的站点。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ol><li>我们需要先安装<code>hexo-cli</code>脚手架，脚手架可以帮助我们创建一个完整可用的项目。在本地打开一个cmd窗口运行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span></pre></td></tr></table></figure></li><li>然后使用hexo新建一个项目：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo init 新建项目文件名</span></pre></td></tr></table></figure></li><li>安装npm包依赖:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install</span></pre></td></tr></table></figure>这时候我们打开刚刚新建的项目文件夹，看下目录结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">项目根目录</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">├── node_modules</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">├── scaffolds # 模版文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">|   ├── _drafts # 草稿文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">|   └── _posts # 文章Markdowm文件 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">└── themes  # 主题文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">├── package.json</span></pre></td></tr></table></figure>这时我们运行<code>hexo s</code>命令启动工程，其中 s 是 server 的缩写：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo s</span></pre></td></tr></table></figure>启动成功后，在浏览器中输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 回车就可以预览效果了！<br><img alt="预览效果" data-src="/posts/undefined/hexo_2.jpg" class="lazyload"></li></ol><p>可能到此处你会觉得奇怪，我们什么都没做，怎么就生成这么好看的一套页面出来了！那这就要归功于<code>hexo-theme</code>了。每一种<code>hexo-theme</code>都内置了大量的样式文件，我们只需简单的配置就能打造出非常酷炫好看的博客网站！hexo中提供了非常多种theme，除此之外，github上也有大量开源的theme供我们自主选择，免费使用！</p><h2 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h2><p>本地hexo博客系统开发完毕后，我们还需要部署到我们前面在github上创建的个人仓库里才能通过站点访问到。 </p><p>在部署之前，第一步，先安装一个插件<code>hexo-deployer-git</code>，用于本地hexo项目连接到远程git仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span></pre></td></tr></table></figure><p>第二步，打开项目根目录下的_config.yml配置文件配置远程github仓库的参数。直接拉到_config.yml文件末尾，找到deploy选项，按如下配置：<br><img alt="github配置" data-src="/posts/undefined/hexo_3.jpg" class="lazyload"></p><p>最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hexo g -d</span></pre></td></tr></table></figure><p>稍等一会，在浏览器访问网址： <code>https://用户名.github.io</code> 就会看到你的博客啦！！</p><h2 id="搞定"><a href="#搞定" class="headerlink" title="搞定"></a>搞定</h2><p>至此，我们的个人博客网站就创建好了！后续还会对博客网站加入改进，努力打造出一个炫酷精致的博客网站！</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
